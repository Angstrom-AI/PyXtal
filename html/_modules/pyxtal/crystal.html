
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyxtal.crystal &#8212; PyXtal 0.1dev documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyXtal 0.1dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyxtal.crystal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for generation of random atomic crystals with symmetry constraints. A</span>
<span class="sd">pymatgen- or spglib-type structure object is created, which can be saved to a</span>
<span class="sd">.cif file. Options (preceded by two dashes) are provided for command-line usage</span>
<span class="sd">of the module:  </span>

<span class="sd">    spacegroup (-s): the international spacegroup number (between 1 and 230)</span>
<span class="sd">        to be generated. In the case of a 2D crystal (using option &#39;-d 2&#39;),</span>
<span class="sd">        this will instead be the layer group number (between 1 and 80).</span>
<span class="sd">        Defaults to 36.  </span>

<span class="sd">    element (-e): the chemical symbol of the atom(s) to use. For multiple</span>
<span class="sd">        molecule types, separate entries with commas. Ex: &quot;C&quot;, &quot;H, O, N&quot;.</span>
<span class="sd">        Defaults to Li  </span>

<span class="sd">    numIons (-n): the number of atoms in the PRIMITIVE unit cell</span>
<span class="sd">        (For P-type spacegroups, this is the same as the number of molecules in</span>
<span class="sd">        the conventional unit cell. For A, B, C, and I-centered spacegroups,</span>
<span class="sd">        this is half the number of the conventional cell. For F-centered unit</span>
<span class="sd">        cells, this is one fourth the number of the conventional cell.).</span>
<span class="sd">        For multiple atom types, separate entries with commas.</span>
<span class="sd">        Ex: &quot;8&quot;, &quot;1, 4, 12&quot;. Defaults to 16  </span>

<span class="sd">    factor (-f): the relative volume factor used to generate the unit cell.</span>
<span class="sd">        Larger values result in larger cells, with atoms spaced further apart.</span>
<span class="sd">        If generation fails after max attempts, consider increasing this value.</span>
<span class="sd">        Defaults to 2.0  </span>

<span class="sd">    verbosity (-v): the amount of information which should be printed for each</span>
<span class="sd">        generated structure. For 0, only prints the requested and generated</span>
<span class="sd">        spacegroups. For 1, also prints the contents of the generated pymatgen</span>
<span class="sd">        structure. Defaults to 0  </span>

<span class="sd">    attempts (-a): the number of structures to generate. Note: if any of the</span>
<span class="sd">        attempts fail, the number of generated structures will be less than this</span>
<span class="sd">        value. Structures will be output to separate cif files. Defaults to 1  </span>

<span class="sd">    outdir (-o): the file directory where cif files will be output to.</span>
<span class="sd">        Defaults to &quot;out&quot;</span>

<span class="sd">    dimension (-d): 3 for 3D, or 2 for 2D. If 2D, generates a 2D crystal using</span>
<span class="sd">        a layer group number instead of a space group number.  </span>

<span class="sd">    thickness (-t): The thickness, in Angstroms, to use when generating a</span>
<span class="sd">        2D crystal. Note that this will not necessarily be one of the lattice</span>
<span class="sd">        vectors, but will represent the perpendicular distance along the non-</span>
<span class="sd">        periodic direction. Defaults to 2.0    </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="c1">#from pkg_resources import resource_string</span>
<span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="k">import</span> <span class="n">resource_filename</span>
<span class="kn">from</span> <span class="nn">spglib</span> <span class="k">import</span> <span class="n">get_symmetry_dataset</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.groups</span> <span class="k">import</span> <span class="n">sg_symbol_from_int_number</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">generate_full_symmops</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.operations</span> <span class="k">import</span> <span class="n">SymmOp</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.cif</span> <span class="k">import</span> <span class="n">CifWriter</span>

<span class="kn">from</span> <span class="nn">optparse</span> <span class="k">import</span> <span class="n">OptionParser</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">uniform</span> <span class="k">as</span> <span class="n">rand</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">choice</span> <span class="k">as</span> <span class="n">choose</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">acos</span><span class="p">,</span> <span class="n">fabs</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">read_csv</span>

<span class="kn">from</span> <span class="nn">pyxtal.database.element</span> <span class="k">import</span> <span class="n">Element</span>
<span class="kn">import</span> <span class="nn">pyxtal.database.hall</span> <span class="k">as</span> <span class="nn">hall</span>
<span class="kn">from</span> <span class="nn">pyxtal.database.layergroup</span> <span class="k">import</span> <span class="n">Layergroup</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">OperationAnalyzer</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">angle</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">random_vector</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">are_equal</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">random_shear_matrix</span>


<span class="c1">#some optional libs</span>
<span class="c1">#from vasp import read_vasp</span>
<span class="c1">#from pymatgen.symmetry.analyzer import SpacegroupAnalyzer</span>
<span class="c1">#from os.path import isfile</span>

<span class="c1">#Define variables</span>
<span class="c1">#------------------------------</span>
<span class="n">tol_m</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#seperation tolerance in Angstroms</span>
<span class="n">max1</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#Attempts for generating lattices</span>
<span class="n">max2</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#Attempts for a given lattice</span>
<span class="n">max3</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#Attempts for a given Wyckoff position</span>
<span class="n">minvec</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="c1">#minimum vector length</span>
<span class="n">ang_min</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">ang_max</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">Euclidean_lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">wyckoff_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/wyckoff_list.csv&quot;</span><span class="p">))</span>
<span class="n">wyckoff_symmetry_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/wyckoff_symmetry.csv&quot;</span><span class="p">))</span>
<span class="n">wyckoff_generators_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/wyckoff_generators.csv&quot;</span><span class="p">))</span>
<span class="n">rod_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/rod.csv&quot;</span><span class="p">))</span>
<span class="n">layer_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/layer.csv&quot;</span><span class="p">))</span>

<span class="c1">#Define functions</span>
<span class="c1">#------------------------------</span>

<div class="viewcode-block" id="filtered_coords"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.filtered_coords">[docs]</a><span class="k">def</span> <span class="nf">filtered_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of 3d fractional coordinates or a single 3d point, transform</span>
<span class="sd">    all coordinates to less than 1 and greater than 0. If one axis is not</span>
<span class="sd">    periodic, does not transform the coordinates along that axis. For example,</span>
<span class="sd">    for the point [1.2,1.6, -.4] with periodicity along the x and z axes, but</span>
<span class="sd">    not the y axis (PBC=2), the function would return [0.2, 1.6, 0.6].</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: a list or array of real 3d vectors, or a single real 3d vector</span>
<span class="sd">        PBC: the axis, if any, which is not periodic. 1, 2, and 3 correspond</span>
<span class="sd">            to x, y, and z repectively</span>

<span class="sd">    Returns:</span>
<span class="sd">        a new list of coordinates (or single point) with values scaled between</span>
<span class="sd">        0 and 1, except for values on the non-periodic axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">new_coords</span> <span class="o">=</span> <span class="n">coords0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">coords0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_coords</span><span class="p">[:,</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords0</span><span class="p">[:,</span><span class="n">x</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_coords</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords0</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: invalid array dimensions for filtered_coords. Shape: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">new_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">coords</span>
    <span class="k">return</span> <span class="n">new_coords</span></div>

<div class="viewcode-block" id="gaussian"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.gaussian">[docs]</a><span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a random number from a Gaussian probability distribution centered</span>
<span class="sd">    between min and max. sigma is the number of standard deviations that min</span>
<span class="sd">    and max are away from the center. Thus, sigma is also the largest possible</span>
<span class="sd">    number of standard deviations corresponding to the returned value. sigma=2</span>
<span class="sd">    corresponds to a 95.45% probability of choosing a number between min and</span>
<span class="sd">    max.</span>

<span class="sd">    Args:</span>
<span class="sd">        min: the minimum acceptable value</span>
<span class="sd">        max: the maximum acceptable value</span>
<span class="sd">        sigma: the number of standard deviations between the center and min or max</span>

<span class="sd">    Returns:</span>
<span class="sd">        a value chosen randomly between min and max</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="o">+</span><span class="nb">min</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="nb">max</span><span class="o">-</span><span class="nb">min</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">delta</span><span class="o">/</span><span class="n">sigma</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="nb">min</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span></div>
            
<div class="viewcode-block" id="letter_from_index"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.letter_from_index">[docs]</a><span class="k">def</span> <span class="nf">letter_from_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a Wyckoff position&#39;s index within a spacegroup, return its number</span>
<span class="sd">    and letter e.g. &#39;4a&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        index: a single integer describing the WP&#39;s index within the</span>
<span class="sd">            spacegroup (0 is the general position)</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">   </span>
<span class="sd">    Returns:</span>
<span class="sd">        the Wyckoff letter corresponding to the Wyckoff position (for example,</span>
<span class="sd">        for position 4a, the function would return &#39;a&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="s2">&quot;abcdefghijklmnopqrstuvwxyzA&quot;</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">letters</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="index_from_letter"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.index_from_letter">[docs]</a><span class="k">def</span> <span class="nf">index_from_letter</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the Wyckoff letter, returns the index of a Wyckoff position within</span>
<span class="sd">    the spacegroup</span>

<span class="sd">    Args:</span>
<span class="sd">        letter: The wyckoff letter</span>
<span class="sd">        sg: the internationl spacegroup number</span>

<span class="sd">    Returns:</span>
<span class="sd">        a single index specifying the location of the Wyckoff position within</span>
<span class="sd">        the spacegroup (0 is the general position)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="s2">&quot;abcdefghijklmnopqrstuvwxyzA&quot;</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">letters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span></div>

<div class="viewcode-block" id="jk_from_i"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.jk_from_i">[docs]</a><span class="k">def</span> <span class="nf">jk_from_i</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">olist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an organized list (Wyckoff positions or orientations), determine the</span>
<span class="sd">    two indices which correspond to a single index for an unorganized list.</span>
<span class="sd">    Used mainly for organized Wyckoff position lists, but can be used for other</span>
<span class="sd">    lists organized in a similar way</span>

<span class="sd">    Args:</span>
<span class="sd">        i: a single index corresponding to the item&#39;s location in the</span>
<span class="sd">            unorganized list</span>
<span class="sd">        olist: the organized list</span>

<span class="sd">    Returns:</span>
<span class="sd">        [j, k]: two indices corresponding to the item&#39;s location in the</span>
<span class="sd">            organized list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">j</span> <span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">olist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Incorrect Wyckoff position list or index passed to jk_from_i&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="i_from_jk"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.i_from_jk">[docs]</a><span class="k">def</span> <span class="nf">i_from_jk</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">olist</span><span class="p">):</span>
    <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">olist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span></div>

<div class="viewcode-block" id="ss_string_from_ops"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.ss_string_from_ops">[docs]</a><span class="k">def</span> <span class="nf">ss_string_from_ops</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the Hermann-Mauguin symbol for a site symmetry group, using a list of</span>
<span class="sd">    SymmOps as input. Note that the symbol does not necessarily refer to the</span>
<span class="sd">    x,y,z axes. For information on reading these symbols, see:</span>
<span class="sd">    http://en.wikipedia.org/wiki/Hermann-Mauguin_notation#Point_groups</span>

<span class="sd">    Args:</span>
<span class="sd">        ops: a list of SymmOp objects representing the site symmetry</span>
<span class="sd">        sg: International number of the spacegroup. Used to determine which</span>
<span class="sd">            axes to show. For example, a 3-fold rotation in a cubic system is</span>
<span class="sd">            written as &quot;.3.&quot;, whereas a 3-fold rotation in a trigonal system is</span>
<span class="sd">            written as &quot;3..&quot;</span>
<span class="sd">        complete: whether or not all symmetry operations in the group</span>
<span class="sd">            are present. If False, we generate the rest</span>

<span class="sd">    Returns:</span>
<span class="sd">        a string representing the site symmetry. Ex: &quot;2mm&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Return the symbol for a single axis</span>
    <span class="c1">#Will be called later in the function</span>
    <span class="k">def</span> <span class="nf">get_symbol</span><span class="p">(</span><span class="n">opas</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">has_reflection</span><span class="p">):</span>
        <span class="c1">#ops: a list of Symmetry operations about the axis</span>
        <span class="c1">#order: highest order of any symmetry operation about the axis</span>
        <span class="c1">#has_reflection: whether or not the axis has mirror symmetry</span>
        <span class="k">if</span> <span class="n">has_reflection</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#rotations have priority</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotation&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/m&quot;</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotoinversion&quot;</span>
                    <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">return</span> <span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;m&quot;</span>
        <span class="k">elif</span> <span class="n">has_reflection</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1">#rotoinversion has priority</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotoinversion&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotation&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;.&quot;</span>
    <span class="c1">#Given a list of single-axis symbols, return the one with highest symmetry</span>
    <span class="c1">#Will be called later in the function</span>
    <span class="k">def</span> <span class="nf">get_highest_symbol</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="n">symbol_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;2&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;-2&#39;</span><span class="p">,</span><span class="s1">&#39;2/m&#39;</span><span class="p">,</span><span class="s1">&#39;3&#39;</span><span class="p">,</span><span class="s1">&#39;4&#39;</span><span class="p">,</span><span class="s1">&#39;-4&#39;</span><span class="p">,</span><span class="s1">&#39;4/m&#39;</span><span class="p">,</span><span class="s1">&#39;-3&#39;</span><span class="p">,</span><span class="s1">&#39;6&#39;</span><span class="p">,</span><span class="s1">&#39;-6&#39;</span><span class="p">,</span><span class="s1">&#39;6/m&#39;</span><span class="p">]</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">symbol_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">symbol_list</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>
    <span class="c1">#Return whether or not two axes are symmetrically equivalent</span>
    <span class="c1">#It is assumed that both axes possess the same symbol</span>
    <span class="c1">#Will be called within combine_axes</span>
    <span class="k">def</span> <span class="nf">are_symmetrically_equivalent</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">):</span>
        <span class="n">axis1</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>
        <span class="n">axis2</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span>
        <span class="n">condition1</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">condition2</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#Check for an operation mapping one axis onto the other</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">condition1</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">condition2</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">new1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
                <span class="n">new2</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">condition1</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new2</span><span class="p">,</span> <span class="n">axis1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">condition2</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">condition1</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">condition2</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="c1">#Given a list of axis indices, return the combined symbol</span>
    <span class="c1">#Axes may or may not be symmetrically equivalent, but must be of the same</span>
    <span class="c1">#type (x/y/z, face-diagonal, body-diagonal)</span>
    <span class="c1">#Will be called for mid- and high-symmetry crystallographic point groups</span>
    <span class="k">def</span> <span class="nf">combine_axes</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">orders</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">reflections</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symbols</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="s2">&quot;.&quot;</span>
        <span class="c1">#Remove redundant axes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">symbols</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">are_symmetrically_equivalent</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                                <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="c1">#Combine symbols for non-equivalent axes</span>
        <span class="n">new_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">new_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">while</span> <span class="n">new_symbols</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">highest</span> <span class="o">=</span> <span class="n">get_highest_symbol</span><span class="p">(</span><span class="n">new_symbols</span><span class="p">)</span>
            <span class="n">symbol</span> <span class="o">+=</span> <span class="n">highest</span>
            <span class="n">new_symbols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">highest</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: could not combine site symmetry axes.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
    <span class="c1">#Generate needed ops</span>
    <span class="k">if</span> <span class="n">complete</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">generate_full_symmops</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span>
    <span class="c1">#Get OperationAnalyzer object for all ops</span>
    <span class="n">opas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">opas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OperationAnalyzer</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
    <span class="c1">#Store the symmetry of each axis</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[[],[],[],[],[],[],[],[],[],[],[],[],[]]</span>
    <span class="n">has_inversion</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#Store possible symmetry axes for crystallographic point groups</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;identity&quot;</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;inversion&quot;</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opa</span><span class="p">)</span>
            <span class="c1">#Store uncommon axes for trigonal and hexagonal lattices</span>
            <span class="k">if</span> <span class="n">found</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
                <span class="c1">#Check that new axis is not symmetrically equivalent to others</span>
                <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">are_symmetrically_equivalent</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">unique</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">opa</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">unique</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;inversion&quot;</span><span class="p">:</span>
            <span class="n">has_inversion</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Determine how many high-symmetry axes are present</span>
    <span class="n">n_axes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#Store the order of each axis</span>
    <span class="n">orders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#Store whether or not each axis has reflection symmetry</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">high_symm</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">has_reflection</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">high_symm</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">order</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span>
            <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotoinversion&quot;</span><span class="p">:</span>
                <span class="n">has_reflection</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">high_symm</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_axes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">reflections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">has_reflection</span><span class="p">)</span>
    <span class="c1">#Triclinic, monoclinic, orthorhombic</span>
    <span class="c1">#Positions in symbol refer to x,y,z axes respectively</span>
    <span class="k">if</span> <span class="n">sg</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">74</span><span class="p">:</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>
                <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;...&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;...&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-1&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
    <span class="c1">#Trigonal, Hexagonal, Tetragonal</span>
    <span class="k">elif</span> <span class="n">sg</span> <span class="o">&gt;=</span> <span class="mi">75</span> <span class="ow">and</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
        <span class="c1">#1st symbol: z axis</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1">#2nd symbol: x or y axes (whichever have higher symmetry)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#3rd symbol: face-diagonal axes (whichever have highest symmetry)</span>
        <span class="n">s3</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">))))</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">s1</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s2</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s3</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-1&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
    <span class="c1">#Cubic</span>
    <span class="k">elif</span> <span class="n">sg</span> <span class="o">&gt;=</span> <span class="mi">195</span> <span class="ow">and</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">230</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#1st symbol: x, y, and/or z axes (whichever have highest symmetry)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1">#2nd symbol: body-diagonal axes (whichever has highest symmetry)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
        <span class="c1">#3rd symbol: face-diagonal axes (whichever have highest symmetry)</span>
        <span class="n">s3</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">s1</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s2</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s3</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-1&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: invalid spacegroup number&quot;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="create_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.create_matrix">[docs]</a><span class="k">def</span> <span class="nf">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used for calculating distances in lattices with periodic boundary</span>
<span class="sd">    conditions. When multiplied with a set of points, generates additional</span>
<span class="sd">    points in cells adjacent to and diagonal to the original cell</span>

<span class="sd">    Args:</span>
<span class="sd">        PBC: an axis which does not have periodic boundary condition.</span>
<span class="sd">            Ex: PBC=1 cancels periodic boundary conditions along the x axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array of matrices which can be multiplied by a set of</span>
<span class="sd">        coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">j_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">k_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">j_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">k_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_list</span><span class="p">:</span>
                <span class="n">matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.distance">[docs]</a><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Euclidean distance from the origin for a fractional</span>
<span class="sd">    displacement vector. Takes into account the lattice metric and periodic</span>
<span class="sd">    boundary conditions, including up to one non-periodic axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        xyz: a fractional 3d displacement vector. Can be obtained by</span>
<span class="sd">            subtracting one fractional vector from another</span>
<span class="sd">        lattice: a 3x3 matrix describing a unit cell&#39;s lattice vectors</span>
<span class="sd">        PBC: the axis, if any, which is non-periodic. 1, 2, and 3 correspond</span>
<span class="sd">            to x, y, and z respectively.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a scalar for the distance of the point from the origin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">+=</span> <span class="n">xyz</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">matrix</span><span class="p">,[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span>       </div>

<div class="viewcode-block" id="check_distance"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.check_distance">[docs]</a><span class="k">def</span> <span class="nf">check_distance</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">,</span> <span class="n">specie1</span><span class="p">,</span> <span class="n">specie2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the distances between two set of atoms. The first set is</span>
<span class="sd">    generally larger than the second. Distances between coordinates within the</span>
<span class="sd">    first set are not checked, and distances between coordinates within the</span>
<span class="sd">    second set are not checked. Only distances between points from different</span>
<span class="sd">    sets are checked.</span>

<span class="sd">    Args:</span>
<span class="sd">        coord1: multiple lists of fractional coordinates e.g. [[[.1,.6,.4]</span>
<span class="sd">            [.3,.8,.2]],[[.4,.4,.4],[.3,.3,.3]]]</span>
<span class="sd">        coord2: a list of new fractional coordinates e.g. [[.7,.8,.9],</span>
<span class="sd">            [.4,.5,.6]]</span>
<span class="sd">        specie1: a list of atomic symbols for coord1. Ex: [&#39;C&#39;, &#39;O&#39;]</span>
<span class="sd">        specie2: the atomic symbol for coord2. Ex: &#39;Li&#39;</span>
<span class="sd">        lattice: matrix describing the unit cell vectors</span>
<span class="sd">        PBC: value to be passed to create_matrix</span>
<span class="sd">        d_factor: the tolerance is multiplied by this amount. Larger values</span>
<span class="sd">            mean atoms must be farther apart</span>

<span class="sd">    Returns:</span>
<span class="sd">        a bool for whether or not the atoms are sufficiently far enough apart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#add PBC</span>
    <span class="n">coord2s</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coord2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">:</span>
            <span class="n">coord2s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="o">+</span><span class="n">m</span><span class="p">)</span>
    <span class="n">coord2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coord2s</span><span class="p">)</span>

    <span class="n">coord2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coord2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">specie1</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="n">d_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">coord2</span><span class="p">))</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">d_factor</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="o">+</span> <span class="n">Element</span><span class="p">(</span><span class="n">specie2</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d_min</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="get_center"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_center">[docs]</a><span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the geometric centers of the clusters under periodic boundary</span>
<span class="sd">    conditions.</span>

<span class="sd">    Args:</span>
<span class="sd">        xyzs: a list of fractional coordinates</span>
<span class="sd">        lattice: a matrix describing the unit cell</span>
<span class="sd">        PBC: a value to be passed to create_matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        x,y,z coordinates for the center of the input coordinate list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix0</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">xyzs</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)</span>
    <span class="n">matrix_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)):</span>
        <span class="n">dist_min</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">atom1</span><span class="p">):</span>
            <span class="c1">#shift atom1 to position close to atom2</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix0</span> <span class="o">+</span> <span class="p">(</span><span class="n">xyzs</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyzs</span><span class="p">[</span><span class="n">atom2</span><span class="p">])</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist_min</span><span class="p">:</span>
                <span class="n">dist_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
                <span class="n">matrix_min</span> <span class="o">=</span> <span class="n">matrix0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)]</span>
        <span class="n">xyzs</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">matrix_min</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">xyzs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-4</span><span class="p">:</span>
            <span class="n">center</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">center</span></div>

<div class="viewcode-block" id="para2matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.para2matrix">[docs]</a><span class="k">def</span> <span class="nf">para2matrix</span><span class="p">(</span><span class="n">cell_para</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of lattic parameters, generates a matrix representing the</span>
<span class="sd">    lattice vectors</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_para: a 1x6 list of lattice parameters [a, b, c, alpha, beta,</span>
<span class="sd">            gamma]. a, b, and c are the length of the lattice vectos, and</span>
<span class="sd">            alpha, beta, and gamma are the angles between these vectors. Can</span>
<span class="sd">            be generated by matrix2para</span>
<span class="sd">        radians: if True, lattice parameters should be in radians. If False,</span>
<span class="sd">            lattice angles should be in degrees</span>
<span class="sd">        format: a string (&#39;lower&#39;, &#39;symmetric&#39;, or &#39;upper&#39;) for the type of</span>
<span class="sd">            matrix to be output</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the unit cell. By default (format=&#39;lower&#39;),</span>
<span class="sd">        the a vector is aligined along the x-axis, and the b vector is in the</span>
<span class="sd">        y-z plane</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">rad</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>
        <span class="n">alpha</span> <span class="o">*=</span> <span class="n">rad</span>
        <span class="n">beta</span> <span class="o">*=</span> <span class="n">rad</span>
        <span class="n">gamma</span> <span class="o">*=</span> <span class="n">rad</span>
    <span class="n">cos_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">cos_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="n">cos_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">sin_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
        <span class="c1">#Generate a lower-diagonal matrix</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">cos_beta</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">cos_alpha</span> <span class="o">-</span> <span class="p">(</span><span class="n">cos_beta</span> <span class="o">*</span> <span class="n">cos_gamma</span><span class="p">)))</span> <span class="o">/</span> <span class="n">sin_gamma</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cos_gamma</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin_gamma</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span>
        <span class="c1">#TODO: allow generation of symmetric matrices</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
        <span class="c1">#Generate an upper-diagonal matrix</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos_beta</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cos_gamma</span> <span class="o">-</span> <span class="p">(</span><span class="n">cos_beta</span> <span class="o">*</span> <span class="n">cos_alpha</span><span class="p">)))</span> <span class="o">/</span> <span class="n">sin_alpha</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cos_alpha</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin_alpha</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="Add_vacuum"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Add_vacuum">[docs]</a><span class="k">def</span> <span class="nf">Add_vacuum</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1">#TODO: add docstring</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">lattice</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">+</span> <span class="n">vacuum</span>
    <span class="n">coor</span><span class="p">[:,</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">coor</span><span class="p">[:,</span><span class="n">dim</span><span class="p">]</span><span class="o">*</span><span class="n">old</span><span class="o">/</span><span class="n">new</span>
    <span class="n">coor</span><span class="p">[:,</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">coor</span><span class="p">[:,</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coor</span><span class="p">[:,</span><span class="n">dim</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.5</span>
    <span class="n">lattice</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
    <span class="k">return</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">coor</span></div>

<div class="viewcode-block" id="Permutation"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Permutation">[docs]</a><span class="k">def</span> <span class="nf">Permutation</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">PB</span><span class="p">):</span>
    <span class="c1">#TODO: add docstring</span>
    <span class="n">para</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
    <span class="n">para1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">para</span><span class="p">)</span>
    <span class="n">coor1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">para1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">para</span><span class="p">[</span><span class="n">PB</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">para1</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">para</span><span class="p">[</span><span class="n">PB</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">coor1</span><span class="p">[:,</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">coor</span><span class="p">[:,</span><span class="n">PB</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">para2matrix</span><span class="p">(</span><span class="n">para1</span><span class="p">),</span> <span class="n">coor1</span></div>

<div class="viewcode-block" id="matrix2para"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.matrix2para">[docs]</a><span class="k">def</span> <span class="nf">matrix2para</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a 3x3 matrix representing a unit cell, outputs a list of lattice</span>
<span class="sd">    parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: a 3x3 array or list, where the first, second, and third rows</span>
<span class="sd">            represent the a, b, and c vectors respectively</span>
<span class="sd">        radians: if True, outputs angles in radians. If False, outputs in</span>
<span class="sd">            degrees</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 1x6 list of lattice parameters [a, b, c, alpha, beta, gamma]. a, b,</span>
<span class="sd">        and c are the length of the lattice vectos, and alpha, beta, and gamma</span>
<span class="sd">        are the angles between these vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell_para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="c1">#a</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1">#b</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#c</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#alpha</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#beta</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#gamma</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
        <span class="c1">#convert radians to degrees</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="mf">180.</span><span class="o">/</span><span class="n">pi</span>
        <span class="n">cell_para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">deg</span>
        <span class="n">cell_para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*=</span> <span class="n">deg</span>
        <span class="n">cell_para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*=</span> <span class="n">deg</span>
    <span class="k">return</span> <span class="n">cell_para</span></div>

<div class="viewcode-block" id="cellsize"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.cellsize">[docs]</a><span class="k">def</span> <span class="nf">cellsize</span><span class="p">(</span><span class="n">sg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of duplicate atoms in the conventional lattice (in</span>
<span class="sd">    contrast to the primitive cell). Based on the type of cell centering (P,</span>
<span class="sd">    A, C, I, R, or F)</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>

<span class="sd">    Returns:</span>
<span class="sd">        a number between 1 and 4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symbol</span> <span class="o">=</span> <span class="n">sg_symbol_from_int_number</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
    <span class="n">letter</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
    	<span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">]:</span>
    	<span class="k">return</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]:</span>
    	<span class="k">return</span> <span class="mi">3</span>
    <span class="k">elif</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]:</span>
    	<span class="k">return</span> <span class="mi">4</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;Error: Could not determine lattice type&quot;</span></div>

<div class="viewcode-block" id="find_short_dist"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.find_short_dist">[docs]</a><span class="k">def</span> <span class="nf">find_short_dist</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of fractional coordinates, finds pairs which are closer</span>
<span class="sd">    together than tol, and builds the connectivity map</span>

<span class="sd">    Args:</span>
<span class="sd">        coor: a list of fractional 3-dimensional coordinates</span>
<span class="sd">        lattice: a matrix representing the crystal unit cell</span>
<span class="sd">        tol: the distance tolerance for pairing coordinates</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        pairs, graph: (pairs) is a list whose entries have the form [index1,</span>
<span class="sd">        index2, distance], where index1 and index2 correspond to the indices</span>
<span class="sd">        of a pair of points within the supplied list (coor). distance is the</span>
<span class="sd">        distance between the two points. (graph) is a connectivity map in the</span>
<span class="sd">        form of a list. Its first index represents a point within coor, and</span>
<span class="sd">        the second indices represent which point(s) it is connected to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pairs</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">graph</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)):</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">-</span><span class="n">coor</span><span class="p">[</span><span class="n">i2</span><span class="p">],</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
                <span class="c1">#dists.append(dist)</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">,</span><span class="n">dist</span><span class="p">])</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pairs</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-3</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">pairs</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d_min</span><span class="p">]</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">sequence</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">pair0</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pair1</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">pair0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair1</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">pair1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pairs</span><span class="p">,</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="connected_components"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.connected_components">[docs]</a><span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an undirected graph (a 2d array of indices), return a set of</span>
<span class="sd">    connected components, each connected component being an (arbitrarily</span>
<span class="sd">    ordered) array of indices which are connected either directly or</span>
<span class="sd">    indirectly.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph: a list reprenting the connections between points. The first index</span>
<span class="sd">            represents a point, and the 2nd indices represent the points to</span>
<span class="sd">            which the first point is connected. Can be generated by</span>
<span class="sd">            find_short_dist</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of connected components. The first index denotes a separate</span>
<span class="sd">        connected component. The second indices denote the points within the</span>
<span class="sd">        connected component which are connected to each other</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">add_neighbors</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all elements which are connected to el. Return an array which</span>
<span class="sd">        includes these elements and el itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#seen stores already-visited indices</span>
        <span class="k">if</span> <span class="n">seen</span> <span class="o">==</span> <span class="p">[]:</span> <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
        <span class="c1">#iterate through the neighbors (x) of el</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">el</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1">#Recursively find neighbors of x</span>
                <span class="n">add_neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">seen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seen</span>

    <span class="c1">#Create a list of indices to iterate through</span>
    <span class="n">unseen</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)))</span>
    <span class="n">sets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">unseen</span> <span class="o">!=</span> <span class="p">[]):</span>
        <span class="c1">#x is the index we are finding the connected component of</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">unseen</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">sets</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Add neighbors of x to the current connected component</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">add_neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="c1">#Remove indices which have already been found</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">unseen</span><span class="p">:</span> <span class="n">unseen</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">sets</span></div>

<div class="viewcode-block" id="merge_coordinate"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.merge_coordinate">[docs]</a><span class="k">def</span> <span class="nf">merge_coordinate</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">wyckoff</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of fractional coordinates, merges them within a given</span>
<span class="sd">    tolerance, and checks if the merged coordinates satisfy a Wyckoff</span>
<span class="sd">    position. Used for merging general Wyckoff positions into special Wyckoff</span>
<span class="sd">    positions within the random_crystal (and its derivative) classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        coor: a list of fractional coordinates</span>
<span class="sd">        lattice: a 3x3 matrix representing the unit cell</span>
<span class="sd">        wyckoff: an unorganized list of Wyckoff positions to check</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        tol: the cutoff distance for merging coordinates</span>
<span class="sd">        PBC: a number representing the periodic boundary conditions (used for</span>
<span class="sd">            2d and 1d crystals)</span>

<span class="sd">    Returns:</span>
<span class="sd">        coor, index: (coor) is the new list of fractional coordinates after</span>
<span class="sd">        merging, and index is a single index of the Wyckoff position within</span>
<span class="sd">        the spacegroup. If merging is unsuccesful, or no index is found,</span>
<span class="sd">        returns the original coordinates and False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">pairs</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">find_short_dist</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_center</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">group</span><span class="p">],</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">))</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">check_wyckoff_position</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">exact_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">coor</span><span class="p">,</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coor</span> <span class="o">=</span> <span class="n">merged</span>

            <span class="k">else</span><span class="p">:</span><span class="c1">#no way to merge</span>
                <span class="k">return</span> <span class="n">coor</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">check_wyckoff_position</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">exact_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coor</span><span class="p">,</span> <span class="n">index</span></div>

<div class="viewcode-block" id="estimate_volume"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.estimate_volume">[docs]</a><span class="k">def</span> <span class="nf">estimate_volume</span><span class="p">(</span><span class="n">numIons</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates the volume of a unit cell based on the number and types of ions.</span>
<span class="sd">    Assumes each atom takes up a sphere with radius equal to its covalent bond</span>
<span class="sd">    radius.</span>

<span class="sd">    Args:</span>
<span class="sd">        numIons: a list of the number of ions for each specie</span>
<span class="sd">        species: a corresponding list for the specie of each type of ion. Each</span>
<span class="sd">            element in the list should be a string for the atomic symbol</span>
<span class="sd">        factor: an optional factor to multiply the result by. Larger values</span>
<span class="sd">            allow more space between atoms</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a float value for the estimated volume</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">numIon</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">numIons</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">,</span> <span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">vdw_radius</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">+=</span> <span class="n">numIon</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">factor</span><span class="o">*</span><span class="n">volume</span></div>

<div class="viewcode-block" id="generate_lattice"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.generate_lattice">[docs]</a><span class="k">def</span> <span class="nf">generate_lattice</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">tol_m</span><span class="p">,</span> <span class="n">minangle</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">maxattempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a lattice (3x3 matrix) according to the space group symmetry and</span>
<span class="sd">    number of atoms. If the spacegroup has centering, we will transform to</span>
<span class="sd">    conventional cell setting. If the generated lattice does not meet the</span>
<span class="sd">    minimum angle and vector requirements, we try to generate a new one, up to</span>
<span class="sd">    maxattempts times.</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: International number of the space group</span>
<span class="sd">        volume: volume of the conventional unit cell</span>
<span class="sd">        minvec: minimum allowed lattice vector length (among a, b, and c)</span>
<span class="sd">        minangle: minimum allowed lattice angle (among alpha, beta, and gamma)</span>
<span class="sd">        max_ratio: largest allowed ratio of two lattice vector lengths</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the lattice vectors of the unit cell. If</span>
<span class="sd">        generation fails, outputs a warning message and returns empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxangle</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-</span><span class="n">minangle</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxattempts</span><span class="p">):</span>
        <span class="c1">#Triclinic</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#Derive lattice constants from a random matrix</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">random_shear_matrix</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)))</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">abc</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">x</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="c1">#Monoclinic</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span>  <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">abc</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">x</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="c1">#Orthorhombic</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">74</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">abc</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">x</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="c1">#Tetragonal</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">142</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">#Trigonal/Rhombohedral/Hexagonal</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">#Cubic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span>
        <span class="c1">#Check that lattice meets requirements</span>
        <span class="n">maxvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">minvec</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minvec</span> <span class="o">&lt;</span> <span class="n">maxvec</span><span class="p">:</span>
            <span class="c1">#Check minimum Euclidean distances</span>
            <span class="n">smallvec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)))</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&gt;</span><span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">maxvec</span>
            <span class="ow">and</span> <span class="n">smallvec</span> <span class="o">&lt;</span> <span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&gt;</span><span class="n">minangle</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&lt;</span><span class="n">maxangle</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span>
            <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>
    <span class="c1">#If maxattempts tries have been made without success</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate lattice after &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; attempts for volume &quot;</span><span class="p">,</span> <span class="n">volume</span><span class="p">)</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="generate_lattice_2D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.generate_lattice_2D">[docs]</a><span class="k">def</span> <span class="nf">generate_lattice_2D</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">tol_m</span><span class="p">,</span> <span class="n">minangle</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">maxattempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a lattice (3x3 matrix) according to the spacegroup symmetry and</span>
<span class="sd">    number of atoms. If the spacegroup has centering, we will transform to</span>
<span class="sd">    conventional cell setting. If the generated lattice does not meet the</span>
<span class="sd">    minimum angle and vector requirements, we try to generate a new one, up to</span>
<span class="sd">    maxattempts times.</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: International number of the space group</span>
<span class="sd">        volume: volume of the lattice</span>
<span class="sd">        thickness: 3rd-dimensional thickness of the unit cell</span>
<span class="sd">        P: permuation info about the cell obtained from the layergroup class</span>
<span class="sd">        minvec: minimum allowed lattice vector length (among a, b, and c)</span>
<span class="sd">        minangle: minimum allowed lattice angle (among alpha, beta, and gamma)</span>
<span class="sd">        max_ratio: largest allowed ratio of two lattice vector lengths</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the lattice vectors of the unit cell. If</span>
<span class="sd">        generation fails, outputs a warning message and returns empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Store the non-periodic axis</span>
    <span class="n">PBC</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">maxangle</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-</span><span class="n">minangle</span>
    <span class="n">abc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thickness</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span>  <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxattempts</span><span class="p">):</span>
        <span class="c1">#Triclinic</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">random_shear_matrix</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)))</span>
            <span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">x</span> <span class="c1">#scale thickness by outer product of vectors</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1">#Monoclinic</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1">#Orthorhombic</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">74</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>

        <span class="c1">#Tetragonal</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">142</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">thickness</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1">#Trigonal/Rhombohedral/Hexagonal</span>
        <span class="k">elif</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">abc</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)(</span><span class="n">thickness</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PBC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">thickness</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">para</span>
        <span class="sd">&#39;&#39;&#39;para1 = deepcopy(para)</span>
<span class="sd">        for axis in [0,1,2]:</span>
<span class="sd">            para1[axis] = para[P[axis]-1]</span>
<span class="sd">            para1[axis+3] = para[P[axis]+2]</span>
<span class="sd">        return para1&#39;&#39;&#39;</span>

    <span class="c1">#If maxattempts tries have been made without success</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate lattice after &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; attempts&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="choose_wyckoff"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.choose_wyckoff">[docs]</a><span class="k">def</span> <span class="nf">choose_wyckoff</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a Wyckoff position to fill based on the current number of atoms</span>
<span class="sd">    needed to be placed within a unit cell</span>
<span class="sd">    Rules:</span>
<span class="sd">        1) The new position&#39;s multiplicity is equal/less than (number).</span>
<span class="sd">        2) We prefer positions with large multiplicity.</span>

<span class="sd">    Args:</span>
<span class="sd">        wyckoffs: an organized list of Wyckoff positions</span>
<span class="sd">        number: the number of atoms still needed in the unit cell</span>

<span class="sd">    Returns:</span>
<span class="sd">        a single index for the Wyckoff position. If no position is found,</span>
<span class="sd">        returns False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rand</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">:</span> <span class="c1">#choose from high to low</span>
        <span class="k">for</span> <span class="n">wyckoff</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">good_wyckoff</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wyckoff</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wyckoff</span><span class="p">:</span>
                    <span class="n">good_wyckoff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_wyckoff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="n">good_wyckoff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="get_wyckoffs"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_wyckoffs">[docs]</a><span class="k">def</span> <span class="nf">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given space group. Has option to</span>
<span class="sd">    organize the list based on multiplicity (this is used for</span>
<span class="sd">    random_crystal.wyckoffs) For an unorganized list:</span>

<span class="sd">    1st index: index of WP in sg (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For an organized list:</span>

<span class="sd">    1st index: specifies multiplicity (0 is the largest multiplicity)</span>

<span class="sd">    2nd index: corresponds to a Wyckoff position within the group of equal</span>
<span class="sd">        multiplicity.</span>

<span class="sd">    3nd index: corresponds to a SymmOp object within the Wyckoff position</span>

<span class="sd">    You may switch between organized and unorganized lists using the methods</span>
<span class="sd">    i_from_jk and jk_from_i. For example, if a Wyckoff position is the [i]</span>
<span class="sd">    entry in an unorganized list, it will be the [j][k] entry in an organized</span>
<span class="sd">    list.</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">        PB: permutation info for 2d crystals, from the layergroup class</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coor</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>

    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wyckoff_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">coor1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coor1</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                <span class="c1">#invalid wyckoffs for layer group</span>
                <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_layer"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_layer">[docs]</a><span class="k">def</span> <span class="nf">get_layer</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given 2D layer group. Has</span>
<span class="sd">    option to organize the list based on multiplicity (this is used for</span>
<span class="sd">    random_crystal_2D.wyckoffs) For an unorganized list:</span>

<span class="sd">    1st index: index of WP in layer group (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For an organized list:</span>

<span class="sd">    1st index: specifies multiplicity (0 is the largest multiplicity)</span>

<span class="sd">    2nd index: corresponds to a Wyckoff position within the group of equal</span>
<span class="sd">        multiplicity.</span>

<span class="sd">    3nd index: corresponds to a SymmOp object within the Wyckoff position</span>

<span class="sd">    #TODO: Make jk_from_i and i_from_jk compatible with layer and rod groups</span>
<span class="sd">    You may switch between organized and unorganized lists using the methods</span>
<span class="sd">    i_from_jk and jk_from_i. For example, if a Wyckoff position is the [i]</span>
<span class="sd">    entry in an unorganized list, it will be the [j][k] entry in an organized</span>
<span class="sd">    list.</span>

<span class="sd">    For layer groups with more than one possible origin, origin choice 2 is</span>
<span class="sd">    used.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the international layer group number</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">layer_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_rod"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_rod">[docs]</a><span class="k">def</span> <span class="nf">get_rod</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given 1D Rod group. Has option to</span>
<span class="sd">    organize the list based on multiplicity (this is used for</span>
<span class="sd">    random_crystal_1D.wyckoffs) For an unorganized list:</span>

<span class="sd">    1st index: index of WP in layer group (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For an organized list:</span>

<span class="sd">    1st index: specifies multiplicity (0 is the largest multiplicity)</span>

<span class="sd">    2nd index: corresponds to a Wyckoff position within the group of equal</span>
<span class="sd">        multiplicity.</span>

<span class="sd">    3nd index: corresponds to a SymmOp object within the Wyckoff position</span>

<span class="sd">    #TODO: Make jk_from_i and i_from_jk compatible with layer and rod groups</span>
<span class="sd">    You may switch between organized and unorganized lists using the methods</span>
<span class="sd">    i_from_jk and jk_from_i. For example, if a Wyckoff position is the [i]</span>
<span class="sd">    entry in an unorganized list, it will be the [j][k] entry in an organized</span>
<span class="sd">    list.</span>

<span class="sd">    For Rod groups with more than one possible setting, setting choice 1</span>
<span class="sd">    is used.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the international Rod group number</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">rod_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_wyckoff_symmetry"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_wyckoff_symmetry">[docs]</a><span class="k">def</span> <span class="nf">get_wyckoff_symmetry</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff position site symmetry for a given space group.</span>
<span class="sd">    1st index: index of WP in sg (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a point within the WP</span>
<span class="sd">    3rd index: a site symmetry SymmOp of the point</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3d list of SymmOp objects representing the site symmetry of each</span>
<span class="sd">        point in each Wyckoff position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coor</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">symmetry_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wyckoff_symmetry_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">])</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&gt;=</span> <span class="mi">143</span> <span class="ow">and</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symmetry_strings</span><span class="p">,</span> <span class="n">wyckoffs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coor1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coor1</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="c1">#Loop over points in WP</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="c1">#Loop over ops</span>
                    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                        <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#Loop over points in WP</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="c1">#Loop over ops</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="get_wyckoff_generators"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_wyckoff_generators">[docs]</a><span class="k">def</span> <span class="nf">get_wyckoff_generators</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff generators for a given space group.</span>
<span class="sd">    1st index: index of WP in sg (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a generator for the WP</span>
<span class="sd">    This function is useful for rotating molecules based on Wyckoff position,</span>
<span class="sd">    since special Wyckoff positions only encode positional information, but not</span>
<span class="sd">    information about the orientation. The generators for each Wyckoff position</span>
<span class="sd">    form a subset of the spacegroup&#39;s general Wyckoff position.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a 2d list of SymmOp objects which can be used to generate a Wyckoff position given a</span>
<span class="sd">        single fractional (x,y,z) coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coor</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>

    <span class="n">generator_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wyckoff_generators_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">])</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">generator_strings</span><span class="p">,</span> <span class="n">wyckoffs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coor1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coor1</span><span class="p">[</span><span class="n">PBC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                <span class="c1">#invalid generators for layer group</span>
                <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">generators</span></div>


<div class="viewcode-block" id="site_symm"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.site_symm">[docs]</a><span class="k">def</span> <span class="nf">site_symm</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">Euclidean_lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point and a general Wyckoff position, return the list of symmetry</span>
<span class="sd">    operations leaving the point (coordinate or SymmOp) invariant. The returned</span>
<span class="sd">    SymmOps are a subset of the general position. The site symmetry can be used</span>
<span class="sd">    for determining the Wyckoff position for a set of points, or for</span>
<span class="sd">    determining the valid orientations of a molecule within a given Wyckoff</span>
<span class="sd">    position.</span>

<span class="sd">    Args:</span>
<span class="sd">        point: a 1x3 coordinate or SymmOp object to find the symmetry of. If a</span>
<span class="sd">            SymmOp is given, the returned symmetries must also preserve the</span>
<span class="sd">            point&#39;s orientaion</span>
<span class="sd">        gen_pos: the general position of the spacegroup. Can be obtained using</span>
<span class="sd">            get_wyckoffs(sg)[0], where sg is the desired spacegroup number</span>
<span class="sd">        tol:</span>
<span class="sd">            the numberical tolerance for determining equivalent positions and</span>
<span class="sd">            orientations.</span>
<span class="sd">        lattice:</span>
<span class="sd">            a 3x3 matrix representing the lattice vectors of the unit cell</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of SymmOp objects which leave the given point invariant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Convert point into a SymmOp</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SymmOp</span><span class="p">:</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">point</span><span class="p">)</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">gen_pos</span><span class="p">:</span>
        <span class="n">is_symmetry</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#Calculate the effect of applying op to point</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="p">((</span><span class="n">op</span><span class="o">*</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">affine_matrix</span> <span class="o">-</span> <span class="n">point</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">)</span>
        <span class="c1">#Check that the rotation matrix is unaltered by op</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">difference</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
            <span class="n">is_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#Check that the displacement is less than tol</span>
        <span class="n">displacement</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">translation_vector</span>
        <span class="k">if</span> <span class="n">distance</span><span class="p">(</span><span class="n">displacement</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">is_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">is_symmetry</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;The actual site symmetry&#39;s translation vector may vary from op by</span>
<span class="sd">            a factor of +1 or -1 (especially when op contains +-1/2).</span>
<span class="sd">            We record this to distinguish between special Wyckoff positions.</span>
<span class="sd">            As an example, consider the point (-x+1/2,-x,x+1/2) in position 16c</span>
<span class="sd">            of space group Ia-3(206). The site symmetry includes the operations</span>
<span class="sd">            (-z+1,x-1/2,-y+1/2) and (y+1/2,-z+1/2,-x+1). These operations are</span>
<span class="sd">            not listed in the general position, but correspond to the operations</span>
<span class="sd">            (-z,x+1/2,-y+1/2) and (y+1/2,-z+1/2,-x), respectively, just shifted</span>
<span class="sd">            by (+1,-1,0) and (0,0,+1), respectively.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">translation_vector</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">displacement</span><span class="p">))</span>
            <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="find_generating_point"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.find_generating_point">[docs]</a><span class="k">def</span> <span class="nf">find_generating_point</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of coordinates and Wyckoff generators, return the coord which</span>
<span class="sd">    can be used to generate the others. This is useful for molecular Wyckoff</span>
<span class="sd">    positions, for which the orientation, and not just the position, is</span>
<span class="sd">    needed for each point in the Wyckoff position. Thus, we need to know which</span>
<span class="sd">    coordinates to use for x, y, and z, so that rotations can be applied</span>
<span class="sd">    correctly using the Wyckoff geneators</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: a list of fractional coordinates corresponding to a Wyckoff</span>
<span class="sd">            position</span>
<span class="sd">        generators: the list of Wyckoff generators for the Wyckoff position.</span>
<span class="sd">            Can be obtained from get_wyckoff_generators</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a fractional coordinate [x, y, z] corresponding to the first listed</span>
<span class="sd">        point in the Wyckoff position</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="n">tmp_c</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">tmp_c</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">generated</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">)</span>
        <span class="n">generated</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">generated</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">index_list1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">)))</span>
        <span class="n">index_list2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generated</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">generated</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: coordinate and generator lists have unequal length.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In check_wyckoff_position.find_generating_point:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(coords): &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;, len(generators): &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generators</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">generated</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=.</span><span class="mi">001</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=.</span><span class="mi">001</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index1</span> <span class="ow">in</span> <span class="n">index_list1</span> <span class="ow">and</span> <span class="n">index2</span> <span class="ow">in</span> <span class="n">index_list2</span><span class="p">:</span>
                        <span class="n">index_list1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span>
                        <span class="n">index_list2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="n">index_list2</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">coord</span>
    <span class="c1">#If no valid coordinate is found</span>
    <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="check_wyckoff_position"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.check_wyckoff_position">[docs]</a><span class="k">def</span> <span class="nf">check_wyckoff_position</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">wyckoffs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of points, returns a single index of a matching Wyckoff</span>
<span class="sd">    position in the space group. Checks the site symmetry of each supplied</span>
<span class="sd">    point against the site symmetry for each point in the Wyckoff position.</span>

<span class="sd">    Args:</span>
<span class="sd">        points: a list of 3d coordinates or SymmOps to check</span>
<span class="sd">        sg: the international space group number to check</span>
<span class="sd">        wyckoffs: a list of Wyckoff positions obtained from get_wyckoffs.</span>
<span class="sd">        exact_translation: whether we require two SymmOps to have exactly equal</span>
<span class="sd">            translational components. If false, translations related by +-1</span>
<span class="sd">            are considered equal. If points have been directly generated from</span>
<span class="sd">            a Wyckoff position, we may set this to True. Otherwise, leave False</span>

<span class="sd">    Returns:</span>
<span class="sd">        a single index for the Wyckoff position within the sg. If no matching</span>
<span class="sd">        WP is found, returns False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="c1">#points = np.around((points*1e+10))/1e+10</span>

    <span class="k">if</span> <span class="n">wyckoffs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">gen_pos</span> <span class="o">=</span> <span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gen_pos</span> <span class="o">=</span> <span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">new_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">exact_translation</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="n">w_symm_all</span> <span class="o">=</span> <span class="n">get_wyckoff_symmetry</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">p_symm</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#If exact_translation is false, store WP&#39;s which might be a match</span>
    <span class="n">possible</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_points</span><span class="p">:</span>
        <span class="n">p_symm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site_symm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">):</span>
        <span class="n">w_symm</span> <span class="o">=</span> <span class="n">w_symm_all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_symm</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">w_symm</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">w_symm</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_symm</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">exact_translation</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">w</span><span class="p">:</span>
                            <span class="n">temp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">exact_translation</span><span class="p">:</span>
                        <span class="n">temp2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">op_p</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">op_w</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
                                <span class="c1">#Check that SymmOp&#39;s are equal up to some integer translation</span>
                                <span class="k">if</span> <span class="n">are_equal</span><span class="p">(</span><span class="n">op_w</span><span class="p">,</span> <span class="n">op_p</span><span class="p">,</span> <span class="n">allow_pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                                    <span class="n">temp2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">op_w</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">temp2</span> <span class="o">==</span> <span class="p">[]:</span>
                            <span class="n">temp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">temp</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="c1">#If we find a match with exact translations</span>
                <span class="k">if</span> <span class="n">exact_translation</span><span class="p">:</span>
                    <span class="n">generators</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">find_generating_point</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">i</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">exact_translation</span><span class="p">:</span>
                    <span class="n">possible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1">#If no matching WP&#39;s are found</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1">#If exactly one matching WP is found</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">possible</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">generators</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">find_generating_point</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="c1">#If multiple WP&#39;s are found</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Check that points are generated from generators</span>
        <span class="n">allgen</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">possible</span><span class="p">:</span>
            <span class="n">generators</span> <span class="o">=</span> <span class="n">allgen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">find_generating_point</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="verify_distances"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.verify_distances">[docs]</a><span class="k">def</span> <span class="nf">verify_distances</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks the inter-atomic distance between all pairs of atoms in a crystal.</span>

<span class="sd">    Args:</span>
<span class="sd">        coordinates: a 1x3 list of fractional coordinates</span>
<span class="sd">        species: a list of atomic symbols for each coordinate</span>
<span class="sd">        lattice: a 3x3 matrix representing the lattice vectors of the unit cell</span>
<span class="sd">        factor: a tolerance factor for checking distances. A larger value means</span>
<span class="sd">            atoms must be farther apart</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        True if no atoms are too close together, False if any pair is too close</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
        <span class="n">specie1</span> <span class="o">=</span> <span class="n">species</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">specie2</span> <span class="o">=</span> <span class="n">species</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                <span class="n">d_min</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
                <span class="n">tol</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">specie1</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="o">+</span> <span class="n">Element</span><span class="p">(</span><span class="n">specie2</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d_min</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="random_crystal"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal">[docs]</a><span class="k">class</span> <span class="nc">random_crystal</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing and generating atomic crystals based on symmetry</span>
<span class="sd">    constraints. Given a spacegroup, list of atomic symbols, the stoichiometry,</span>
<span class="sd">    and a volume factor, generates a random crystal consistent with the</span>
<span class="sd">    spacegroup&#39;s symmetry. This crystal is stored as a pymatgen struct via</span>
<span class="sd">    self.struct</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        
        <span class="c1">#Necessary input</span>
        <span class="n">numIons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numIons</span><span class="p">)</span> <span class="c1">#must convert it to np.array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="sd">&quot;&quot;&quot;The supplied volume factor for the unit cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons0</span> <span class="o">=</span> <span class="n">numIons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="sd">&quot;&quot;&quot;The international spacegroup number of the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
        <span class="sd">&quot;&quot;&quot;A list of atomic symbols for the types of atoms in the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msgs</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A list of warning messages to use during generation.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span> <span class="o">=</span> <span class="n">numIons</span> <span class="o">*</span> <span class="n">cellsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The number of each type of atom in the CONVENTIONAL cell&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">estimate_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The volume of the generated unit cell&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup. Sorted by</span>
<span class="sd">        multiplicity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_crystal</span><span class="p">()</span>


<div class="viewcode-block" id="random_crystal.Msgs"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.Msgs">[docs]</a>    <span class="k">def</span> <span class="nf">Msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a set of error and warning message if generation fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span> <span class="o">=</span> <span class="s1">&#39;Error: the number is incompatible with the wyckoff sites choice&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span> <span class="o">=</span> <span class="s1">&#39;Error: failed in the cycle of generating structures&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg3</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of adding species&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg4</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of choosing wyckoff sites&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg5</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the specie&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg6</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the whole structure&#39;</span></div>

<div class="viewcode-block" id="random_crystal.check_compatible"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.check_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">check_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the number of atoms is compatible with the Wyckoff</span>
<span class="sd">        positions. Considers the number of degrees of freedom for each Wyckoff</span>
<span class="sd">        position, and makes sure at least one valid combination of WP&#39;s exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N_site</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">]</span>
        <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#remove WP&#39;s with no freedom once they are filled</span>
        <span class="n">removed_wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">numIon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">:</span>
            <span class="c1">#Check that the number of ions is a multiple of the smallest Wyckoff position</span>
            <span class="k">if</span> <span class="n">numIon</span> <span class="o">%</span> <span class="n">N_site</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Check if smallest WP has at least one degree of freedom</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Subtract from the number of ions beginning with the smallest Wyckoff positions</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">numIon</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                            <span class="n">removed</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">while</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">wp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_wyckoffs</span><span class="p">:</span>
                                <span class="c1">#Check if WP has at least one degree of freedom</span>
                                <span class="n">op</span> <span class="o">=</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">remaining</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])):</span>
                                    <span class="n">removed_wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                    <span class="n">removed</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">has_freedom</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Wyckoff Positions have no degrees of freedom</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="random_crystal.generate_crystal"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.generate_crystal">[docs]</a>    <span class="k">def</span> <span class="nf">generate_crystal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max1</span><span class="o">=</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="o">=</span><span class="n">max2</span><span class="p">,</span> <span class="n">max3</span><span class="o">=</span><span class="n">max3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The main code to generate a random atomic crystal. If successful,</span>
<span class="sd">        stores a pymatgen.core.structure object in self.struct and sets</span>
<span class="sd">        self.valid to True. If unsuccessful, sets self.valid to False and</span>
<span class="sd">        outputs an error message.</span>

<span class="sd">        Args:</span>
<span class="sd">            max1: the number of attempts for generating a lattice</span>
<span class="sd">            max2: the number of attempts for a given lattice</span>
<span class="sd">            max3: the number of attempts for a given Wyckoff position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Check the minimum number of degrees of freedom within the Wyckoff positions</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_compatible</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max1</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max2</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max3</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="c1">#Calculate a minimum vector length for generating a lattice</span>
            <span class="n">minvector</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">),</span> <span class="n">tol_m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cycle1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max1</span><span class="p">):</span>
                <span class="c1">#1, Generate a lattice</span>
                <span class="n">cell_para</span> <span class="o">=</span> <span class="n">generate_lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">minvector</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cell_para</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_matrix</span> <span class="o">=</span> <span class="n">para2matrix</span><span class="p">(</span><span class="n">cell_para</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span> 
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error, volume is not equal to the estimated value: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="s1">&#39; -&gt; &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell_para:  &#39;</span><span class="p">,</span> <span class="n">cell_para</span><span class="p">)</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#to store the added coordinates</span>
                    <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1">#to store the corresponding specie</span>
                    <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">for</span> <span class="n">cycle2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max2</span><span class="p">):</span>
                        <span class="n">coordinates_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">)</span>
                        <span class="n">sites_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_total</span><span class="p">)</span>
                        
            	        <span class="c1">#Add specie by specie</span>
                        <span class="k">for</span> <span class="n">numIon</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
                            <span class="n">numIon_added</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">tol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">,</span> <span class="n">tol_m</span><span class="p">)</span>

                            <span class="c1">#Now we start to add the specie to the wyckoff position</span>
                            <span class="k">for</span> <span class="n">cycle3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max3</span><span class="p">):</span>
                                <span class="c1">#Choose a random Wyckoff position for given multiplicity: 2a, 2b, 2c</span>
                                <span class="n">ops</span> <span class="o">=</span> <span class="n">choose_wyckoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="n">numIon</span><span class="o">-</span><span class="n">numIon_added</span><span class="p">)</span> 
                                <span class="k">if</span> <span class="n">ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            	        	    <span class="c1">#Generate a list of coords from ops</span>
                                    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
                                    <span class="c1">#merge_coordinate if the atoms are close</span>
                                    <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">good_merge</span> <span class="o">=</span> <span class="n">merge_coordinate</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">good_merge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                                        <span class="n">coords_toadd</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span> <span class="c1">#scale the coordinates to [0,1], very important!</span>
                                        <span class="k">if</span> <span class="n">check_distance</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">,</span> <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">sites_tmp</span><span class="p">,</span> <span class="n">specie</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">):</span>
                                            <span class="n">coordinates_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                            <span class="n">sites_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span>
                                            <span class="n">numIon_added</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                                            <span class="n">coordinates_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">)</span>
                                            <span class="n">sites_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_tmp</span><span class="p">)</span>
                                            <span class="k">break</span>

                            <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">!=</span> <span class="n">numIon</span><span class="p">:</span>
                                <span class="k">break</span>  <span class="c1">#need to repeat from the 1st species</span>

                        <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                            <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span> <span class="c1">#reset the coordinates and sites</span>
                            <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">good_structure</span><span class="p">:</span>
                        <span class="n">final_coor</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">final_site</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">final_number</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">final_lattice</span> <span class="o">=</span> <span class="n">cell_matrix</span>
                        <span class="k">for</span> <span class="n">coor</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">,</span> <span class="n">sites_total</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
                                <span class="n">final_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                                <span class="n">final_site</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                                <span class="n">final_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">final_lattice</span>   
                        <span class="sd">&quot;&quot;&quot;A 3x3 matrix representing the lattice of the unit</span>
<span class="sd">                        cell.&quot;&quot;&quot;</span>                 
                        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">)</span>
                        <span class="sd">&quot;&quot;&quot;The fractional coordinates for each molecule in the</span>
<span class="sd">                        final structure&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">final_site</span>
                        <span class="sd">&quot;&quot;&quot;A list of atomic symbols corresponding to the type</span>
<span class="sd">                        of atom for each site in self.coordinates&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_site</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">))</span>
                        <span class="sd">&quot;&quot;&quot;A pymatgen.core.structure.Structure object for the</span>
<span class="sd">                        final generated crystal.&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spg_struct</span> <span class="o">=</span> <span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">),</span> <span class="n">final_number</span><span class="p">)</span>
                        <span class="sd">&quot;&quot;&quot;A list of information describing the generated</span>
<span class="sd">                        crystal, which may be used by spglib for symmetry</span>
<span class="sd">                        analysis.&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="sd">&quot;&quot;&quot;Whether or not a valid crystal was generated.&quot;&quot;&quot;</span>
                        <span class="k">return</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wyckoff positions have no degrees of freedom.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span></div></div>

<div class="viewcode-block" id="random_crystal_2D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_2D">[docs]</a><span class="k">class</span> <span class="nc">random_crystal_2D</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A 2d counterpart to random_crystal. Generates a random atomic crystal based</span>
<span class="sd">    on a 2d layer group instead of a 3d spacegroup. Note that each layer group</span>
<span class="sd">    is equal to a corresponding 3d spacegroup, but without periodicity in one</span>
<span class="sd">    direction. The generated pymatgen structure can be accessed via self.struct</span>

<span class="sd">    Args:</span>
<span class="sd">        number: the layer group number between 1 and 80. NOT equal to the</span>
<span class="sd">            international space group number, which is between 1 and 230</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        thickness: the thickness, in Angstroms, of the unit cell in the 3rd</span>
<span class="sd">            dimension (the direction which is not repeated periodically)</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span> <span class="o">=</span> <span class="n">Layergroup</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The number (between 1 and 80) for the crystal&#39;s layer group.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span><span class="o">.</span><span class="n">sgnumber</span>
        <span class="sd">&quot;&quot;&quot;The number (between 1 and 230) for the international spacegroup.&quot;&quot;&quot;</span>
        <span class="n">numIons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numIons</span><span class="p">)</span> <span class="c1">#must convert it to np.array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="sd">&quot;&quot;&quot;&quot;The volume factor used to generate the unit cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span> <span class="o">=</span> <span class="n">thickness</span>
        <span class="sd">&quot;&quot;&quot;the thickness, in Angstroms, of the unit cell in the 3rd</span>
<span class="sd">        dimension.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons0</span> <span class="o">=</span> <span class="n">numIons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
        <span class="sd">&quot;&quot;&quot;A list of atomic symbols for the types of atoms in the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span><span class="o">.</span><span class="n">permutation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
        <span class="sd">&quot;&quot;&quot;The axis (between 1 and 3) which is not periodic.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span><span class="o">.</span><span class="n">permutation</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> 
        <span class="c1">#TODO: add docstring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span><span class="o">.</span><span class="n">permutation</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> 
        <span class="c1">#TODO: add docstring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msgs</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A list of warning messages to use during generation.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span> <span class="o">=</span> <span class="n">numIons</span> <span class="o">*</span> <span class="n">cellsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The number of each type of atom in the CONVENTIONAL cell&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">estimate_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The volume of the generated unit cell&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">get_wyckoffs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">))</span> 
        <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup. Sorted by</span>
<span class="sd">        multiplicity.&quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_crystal</span><span class="p">()</span>


<div class="viewcode-block" id="random_crystal_2D.Msgs"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_2D.Msgs">[docs]</a>    <span class="k">def</span> <span class="nf">Msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a set of error and warning message if generation fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span> <span class="o">=</span> <span class="s1">&#39;Error: the number is incompatible with the wyckoff sites choice&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span> <span class="o">=</span> <span class="s1">&#39;Error: failed in the cycle of generating structures&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg3</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of adding species&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg4</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of choosing wyckoff sites&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg5</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the specie&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg6</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the whole structure&#39;</span></div>

<div class="viewcode-block" id="random_crystal_2D.check_compatible"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_2D.check_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">check_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the number of atoms is compatible with the Wyckoff</span>
<span class="sd">        positions. Considers the number of degrees of freedom for each Wyckoff</span>
<span class="sd">        position, and makes sure at least one valid combination of WP&#39;s exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N_site</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">]</span>
        <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#remove WP&#39;s with no freedom once they are filled</span>
        <span class="n">removed_wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">numIon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">:</span>
            <span class="c1">#Check that the number of ions is a multiple of the smallest Wyckoff position</span>
            <span class="k">if</span> <span class="n">numIon</span> <span class="o">%</span> <span class="n">N_site</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Check if smallest WP has at least one degree of freedom</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Subtract from the number of ions beginning with the smallest Wyckoff positions</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">numIon</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                            <span class="n">removed</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">while</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">wp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_wyckoffs</span><span class="p">:</span>
                                <span class="c1">#Check if WP has at least one degree of freedom</span>
                                <span class="n">op</span> <span class="o">=</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">remaining</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])):</span>
                                    <span class="n">removed_wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                    <span class="n">removed</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">has_freedom</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Wyckoff Positions have no degrees of freedom</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="random_crystal_2D.generate_crystal"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_2D.generate_crystal">[docs]</a>    <span class="k">def</span> <span class="nf">generate_crystal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max1</span><span class="o">=</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="o">=</span><span class="n">max2</span><span class="p">,</span> <span class="n">max3</span><span class="o">=</span><span class="n">max3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The main code to generate a random atomic crystal. If successful,</span>
<span class="sd">        stores a pymatgen.core.structure object in self.struct and sets</span>
<span class="sd">        self.valid to True. If unsuccessful, sets self.valid to False and</span>
<span class="sd">        outputs an error message.</span>

<span class="sd">        Args:</span>
<span class="sd">            max1: the number of attempts for generating a lattice</span>
<span class="sd">            max2: the number of attempts for a given lattice</span>
<span class="sd">            max3: the number of attempts for a given Wyckoff position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Check the minimum number of degrees of freedom within the Wyckoff positions</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_compatible</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max1</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max2</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max3</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="c1">#Calculate a minimum vector length for generating a lattice</span>
            <span class="n">minvector</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">),</span> <span class="n">tol_m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cycle1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max1</span><span class="p">):</span>
                <span class="c1">#1, Generate a lattice</span>
                <span class="n">cell_para</span> <span class="o">=</span> <span class="n">generate_lattice_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">minvector</span><span class="p">)</span>
                <span class="n">cell_matrix</span> <span class="o">=</span> <span class="n">para2matrix</span><span class="p">(</span><span class="n">cell_para</span><span class="p">)</span>
                <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#to store the added coordinates</span>
                <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1">#to store the corresponding specie</span>
                <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">for</span> <span class="n">cycle2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max2</span><span class="p">):</span>
                    <span class="n">coordinates_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">)</span>
                    <span class="n">sites_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_total</span><span class="p">)</span>
                    
            	    <span class="c1">#Add specie by specie</span>
                    <span class="k">for</span> <span class="n">numIon</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
                        <span class="n">numIon_added</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">tol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">,</span> <span class="n">tol_m</span><span class="p">)</span>

                        <span class="c1">#Now we start to add the specie to the wyckoff position</span>
                        <span class="k">for</span> <span class="n">cycle3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max3</span><span class="p">):</span>
                            <span class="c1">#Choose a random Wyckoff position for given multiplicity: 2a, 2b, 2c</span>
                            <span class="n">ops</span> <span class="o">=</span> <span class="n">choose_wyckoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="n">numIon</span><span class="o">-</span><span class="n">numIon_added</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                	    	    <span class="c1">#Generate a list of coords from ops</span>
                                <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
                                <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">good_merge</span> <span class="o">=</span> <span class="n">merge_coordinate</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">good_merge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                                    <span class="n">coords_toadd</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">)</span> <span class="c1">#scale the coordinates to [0,1], very important!</span>
                                    <span class="k">if</span> <span class="n">check_distance</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">,</span> <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">sites_tmp</span><span class="p">,</span> <span class="n">specie</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">):</span>
                                        <span class="n">coordinates_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                        <span class="n">sites_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span>
                                        <span class="n">numIon_added</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                                        <span class="n">coordinates_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">)</span>
                                        <span class="n">sites_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_tmp</span><span class="p">)</span>
                                        <span class="k">break</span>
                        <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">!=</span> <span class="n">numIon</span><span class="p">:</span>
                            <span class="k">break</span>  <span class="c1">#need to repeat from the 1st species</span>

                    <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                        <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#reset the coordinates and sites</span>
                        <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="n">good_structure</span><span class="p">:</span>
                    <span class="n">final_coor</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">final_site</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">final_number</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">final_lattice</span> <span class="o">=</span> <span class="n">cell_matrix</span>
                    <span class="k">for</span> <span class="n">coor</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">,</span> <span class="n">sites_total</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
                            <span class="n">final_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                            <span class="n">final_site</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                            <span class="n">final_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">final_coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">)</span>
                    <span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_coor</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_coor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PB</span><span class="p">)</span>
                    <span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_coor</span> <span class="o">=</span> <span class="n">Add_vacuum</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_coor</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">final_lattice</span>
                    <span class="sd">&quot;&quot;&quot;A 3x3 matrix representing the lattice of the unit</span>
<span class="sd">                    cell.&quot;&quot;&quot;</span>                        
                    <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">final_coor</span>
                    <span class="sd">&quot;&quot;&quot;The fractional coordinates for each molecule in the</span>
<span class="sd">                    final structure&quot;&quot;&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">final_site</span>  
                    <span class="sd">&quot;&quot;&quot;A list of atomic symbols corresponding to the type</span>
<span class="sd">                    of atom for each site in self.coordinates&quot;&quot;&quot;</span>                  
                    <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_site</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">))</span>
                    <span class="sd">&quot;&quot;&quot;A pymatgen.core.structure.Structure object for the</span>
<span class="sd">                    final generated crystal.&quot;&quot;&quot;</span>                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">spg_struct</span> <span class="o">=</span> <span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">),</span> <span class="n">final_number</span><span class="p">)</span>
                    <span class="sd">&quot;&quot;&quot;A list of information describing the generated</span>
<span class="sd">                    crystal, which may be used by spglib for symmetry</span>
<span class="sd">                    analysis.&quot;&quot;&quot;</span>                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="sd">&quot;&quot;&quot;Whether or not a valid crystal was generated.&quot;&quot;&quot;</span>
                    <span class="k">return</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wyckoff positions have no degrees of freedom.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span></div></div>

<div class="viewcode-block" id="random_crystal_1D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_1D">[docs]</a><span class="k">class</span> <span class="nc">random_crystal_1D</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing and generating atomic crystals based on symmetry</span>
<span class="sd">    constraints. Given a spacegroup, list of atomic symbols, the stoichiometry,</span>
<span class="sd">    and a volume factor, generates a random crystal consistent with the</span>
<span class="sd">    spacegroup&#39;s symmetry. This crystal is stored as a pymatgen struct via</span>
<span class="sd">    self.struct</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        
        <span class="c1">#Necessary input</span>
        <span class="n">numIons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numIons</span><span class="p">)</span> <span class="c1">#must convert it to np.array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="sd">&quot;&quot;&quot;The supplied volume factor for the unit cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons0</span> <span class="o">=</span> <span class="n">numIons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span>
        <span class="sd">&quot;&quot;&quot;The Rod group number (1-75) of the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sg_from_rod</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
        <span class="sd">&quot;&quot;&quot;A list of atomic symbols for the types of atoms in the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msgs</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A list of warning messages to use during generation.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">estimate_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The volume of the generated unit cell&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_rod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup. Sorted by</span>
<span class="sd">        multiplicity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_crystal</span><span class="p">()</span>


<div class="viewcode-block" id="random_crystal_1D.Msgs"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_1D.Msgs">[docs]</a>    <span class="k">def</span> <span class="nf">Msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a set of error and warning message if generation fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span> <span class="o">=</span> <span class="s1">&#39;Error: the number is incompatible with the wyckoff sites choice&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span> <span class="o">=</span> <span class="s1">&#39;Error: failed in the cycle of generating structures&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg3</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of adding species&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg4</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of choosing wyckoff sites&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg5</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the specie&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg6</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the whole structure&#39;</span></div>

<div class="viewcode-block" id="random_crystal_1D.check_compatible"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_1D.check_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">check_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the number of atoms is compatible with the Wyckoff</span>
<span class="sd">        positions. Considers the number of degrees of freedom for each Wyckoff</span>
<span class="sd">        position, and makes sure at least one valid combination of WP&#39;s exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N_site</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">]</span>
        <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#remove WP&#39;s with no freedom once they are filled</span>
        <span class="n">removed_wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">numIon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">:</span>
            <span class="c1">#Check that the number of ions is a multiple of the smallest Wyckoff position</span>
            <span class="k">if</span> <span class="n">numIon</span> <span class="o">%</span> <span class="n">N_site</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Check if smallest WP has at least one degree of freedom</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Subtract from the number of ions beginning with the smallest Wyckoff positions</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">numIon</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                            <span class="n">removed</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">while</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">wp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_wyckoffs</span><span class="p">:</span>
                                <span class="c1">#Check if WP has at least one degree of freedom</span>
                                <span class="n">op</span> <span class="o">=</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">remaining</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])):</span>
                                    <span class="n">removed_wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                    <span class="n">removed</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">has_freedom</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Wyckoff Positions have no degrees of freedom</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="random_crystal_1D.generate_crystal"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_1D.generate_crystal">[docs]</a>    <span class="k">def</span> <span class="nf">generate_crystal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max1</span><span class="o">=</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="o">=</span><span class="n">max2</span><span class="p">,</span> <span class="n">max3</span><span class="o">=</span><span class="n">max3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The main code to generate a random atomic crystal. If successful,</span>
<span class="sd">        stores a pymatgen.core.structure object in self.struct and sets</span>
<span class="sd">        self.valid to True. If unsuccessful, sets self.valid to False and</span>
<span class="sd">        outputs an error message.</span>

<span class="sd">        Args:</span>
<span class="sd">            max1: the number of attempts for generating a lattice</span>
<span class="sd">            max2: the number of attempts for a given lattice</span>
<span class="sd">            max3: the number of attempts for a given Wyckoff position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Check the minimum number of degrees of freedom within the Wyckoff positions</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_compatible</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max1</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max2</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max3</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="c1">#Calculate a minimum vector length for generating a lattice</span>
            <span class="n">minvector</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">),</span> <span class="n">tol_m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cycle1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max1</span><span class="p">):</span>
                <span class="c1">#1, Generate a lattice</span>
                <span class="n">cell_para</span> <span class="o">=</span> <span class="n">generate_lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">minvector</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cell_para</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_matrix</span> <span class="o">=</span> <span class="n">para2matrix</span><span class="p">(</span><span class="n">cell_para</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span> 
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error, volume is not equal to the estimated value: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="s1">&#39; -&gt; &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell_para:  &#39;</span><span class="p">,</span> <span class="n">cell_para</span><span class="p">)</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#to store the added coordinates</span>
                    <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1">#to store the corresponding specie</span>
                    <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">for</span> <span class="n">cycle2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max2</span><span class="p">):</span>
                        <span class="n">coordinates_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">)</span>
                        <span class="n">sites_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_total</span><span class="p">)</span>
                        
            	        <span class="c1">#Add specie by specie</span>
                        <span class="k">for</span> <span class="n">numIon</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
                            <span class="n">numIon_added</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">tol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">,</span> <span class="n">tol_m</span><span class="p">)</span>

                            <span class="c1">#Now we start to add the specie to the wyckoff position</span>
                            <span class="k">for</span> <span class="n">cycle3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max3</span><span class="p">):</span>
                                <span class="c1">#Choose a random Wyckoff position for given multiplicity: 2a, 2b, 2c</span>
                                <span class="n">ops</span> <span class="o">=</span> <span class="n">choose_wyckoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="n">numIon</span><span class="o">-</span><span class="n">numIon_added</span><span class="p">)</span> 
                                <span class="k">if</span> <span class="n">ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            	        	    <span class="c1">#Generate a list of coords from ops</span>
                                    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
                                    <span class="c1">#merge_coordinate if the atoms are close</span>
                                    <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">good_merge</span> <span class="o">=</span> <span class="n">merge_coordinate</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">good_merge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                                        <span class="n">coords_toadd</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span> <span class="c1">#scale the coordinates to [0,1], very important!</span>
                                        <span class="k">if</span> <span class="n">check_distance</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">,</span> <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">sites_tmp</span><span class="p">,</span> <span class="n">specie</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">):</span>
                                            <span class="n">coordinates_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                            <span class="n">sites_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span>
                                            <span class="n">numIon_added</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                                            <span class="n">coordinates_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">)</span>
                                            <span class="n">sites_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_tmp</span><span class="p">)</span>
                                            <span class="k">break</span>

                            <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">!=</span> <span class="n">numIon</span><span class="p">:</span>
                                <span class="k">break</span>  <span class="c1">#need to repeat from the 1st species</span>

                        <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                            <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span> <span class="c1">#reset the coordinates and sites</span>
                            <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">good_structure</span><span class="p">:</span>
                        <span class="n">final_coor</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">final_site</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">final_number</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">final_lattice</span> <span class="o">=</span> <span class="n">cell_matrix</span>
                        <span class="k">for</span> <span class="n">coor</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">,</span> <span class="n">sites_total</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
                                <span class="n">final_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                                <span class="n">final_site</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                                <span class="n">final_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">final_lattice</span>   
                        <span class="sd">&quot;&quot;&quot;A 3x3 matrix representing the lattice of the unit</span>
<span class="sd">                        cell.&quot;&quot;&quot;</span>                 
                        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">)</span>
                        <span class="sd">&quot;&quot;&quot;The fractional coordinates for each molecule in the</span>
<span class="sd">                        final structure&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">final_site</span>
                        <span class="sd">&quot;&quot;&quot;A list of atomic symbols corresponding to the type</span>
<span class="sd">                        of atom for each site in self.coordinates&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_site</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">))</span>
                        <span class="sd">&quot;&quot;&quot;A pymatgen.core.structure.Structure object for the</span>
<span class="sd">                        final generated crystal.&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spg_struct</span> <span class="o">=</span> <span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">),</span> <span class="n">final_number</span><span class="p">)</span>
                        <span class="sd">&quot;&quot;&quot;A list of information describing the generated</span>
<span class="sd">                        crystal, which may be used by spglib for symmetry</span>
<span class="sd">                        analysis.&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="sd">&quot;&quot;&quot;Whether or not a valid crystal was generated.&quot;&quot;&quot;</span>
                        <span class="k">return</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wyckoff positions have no degrees of freedom.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span></div></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1">#-------------------------------- Options -------------------------</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--spacegroup&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;sg&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired space group number (1-230) or layer group number (1-80), e.g., 36&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-e&quot;</span><span class="p">,</span> <span class="s2">&quot;--element&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;element&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;Li&#39;</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired elements: e.g., Li&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;element&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-n&quot;</span><span class="p">,</span> <span class="s2">&quot;--numIons&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;numIons&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired numbers of atoms: 16&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;numIons&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-f&quot;</span><span class="p">,</span> <span class="s2">&quot;--factor&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;factor&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;volume factor: default 3.0&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;factor&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="s2">&quot;--verbosity&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;verbosity&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;verbosity: default 0; higher values print more information&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;verbosity&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-a&quot;</span><span class="p">,</span> <span class="s2">&quot;--attempts&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;attempts&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;number of crystals to generate: default 1&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;attempts&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--outdir&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;outdir&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Directory for storing output cif files: default &#39;out&#39;&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;outdir&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-d&quot;</span><span class="p">,</span> <span class="s2">&quot;--dimension&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;dimension&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;dimension&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired dimension: (3 or 2 for 3d or 2d, respectively)&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-t&quot;</span><span class="p">,</span> <span class="s2">&quot;--thickness&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;thickness&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Thickness, in Angstroms, of a 2D crystal: default 2.0&quot;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">sg</span>
    <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sg</span> <span class="o">&gt;</span> <span class="mi">230</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid space group number. Must be between 1 and 230.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sg</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid layer group number. Must be between 1 and 80.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1d crystals cannot currently be generated. Use dimension 2 or 3.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;0d clusters cannot currently be generated. Use dimension 2 or 3.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid dimension. Use dimension 2 or 3.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">element</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">element</span>
    <span class="n">number</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">numIons</span>
    <span class="n">numIons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">number</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="n">numIons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>
        <span class="n">numIons</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">)]</span>

    <span class="n">factor</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">factor</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Volume factor must be greater than 0.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">verbosity</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">verbosity</span>
    <span class="n">attempts</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">attempts</span>
    <span class="n">outdir</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">outdir</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">dimension</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">thickness</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>

    <span class="n">filecount</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#To check whether a file already exists</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">attempts</span><span class="p">):</span>
        <span class="n">numIons0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numIons</span><span class="p">)</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">sg</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">rand_crystal</span> <span class="o">=</span> <span class="n">random_crystal</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">numIons0</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rand_crystal</span> <span class="o">=</span> <span class="n">random_crystal_2D</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">numIons0</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">timespent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rand_crystal</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="c1">#Output a cif file</span>
            <span class="n">written</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">composition</span><span class="p">)</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">cifpath</span> <span class="o">=</span> <span class="n">outdir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">filecount</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.cif&#39;</span>
                <span class="k">while</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cifpath</span><span class="p">):</span>
                    <span class="n">filecount</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cifpath</span> <span class="o">=</span> <span class="n">outdir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">filecount</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.cif&#39;</span>
                <span class="n">CifWriter</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">struct</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">cifpath</span><span class="p">)</span>
                <span class="n">written</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
            <span class="c1">#POSCAR output</span>
            <span class="c1">#rand_crystal.struct.to(fmt=&quot;poscar&quot;, filename = &#39;1.vasp&#39;)</span>

            <span class="c1">#spglib style structure called cell</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">spg_struct</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)[</span><span class="s1">&#39;number&#39;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Space group  requested: &#39;</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="s1">&#39;generated&#39;</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">written</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Output to &quot;</span><span class="o">+</span><span class="n">cifpath</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Could not write cif file.&quot;</span><span class="p">)</span>

            <span class="c1">#Print additional information about the structure</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time required for generation: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timespent</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">struct</span><span class="p">)</span>


        <span class="c1">#If generation fails</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;something is wrong&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Time spent during generation attempt: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timespent</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyXtal 0.1dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Qiang Zhu, Scott Fredericks.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>