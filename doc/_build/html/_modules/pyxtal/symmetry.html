
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyxtal.symmetry &#8212; PyXtal 0.1dev documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyXtal 0.1dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyxtal.symmetry</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="k">import</span> <span class="n">resource_filename</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>

<span class="kn">from</span> <span class="nn">pymatgen.symmetry.groups</span> <span class="k">import</span> <span class="n">sg_symbol_from_int_number</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">generate_full_symmops</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.operations</span> <span class="k">import</span> <span class="n">SymmOp</span>

<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">read_csv</span>

<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1">#Define variables</span>
<span class="c1">#------------------------------</span>
<span class="n">Euclidean_lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">letters</span> <span class="o">=</span> <span class="s2">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>

<span class="n">wyckoff_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/wyckoff_list.csv&quot;</span><span class="p">))</span>
<span class="n">wyckoff_symmetry_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/wyckoff_symmetry.csv&quot;</span><span class="p">))</span>
<span class="n">wyckoff_generators_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/wyckoff_generators.csv&quot;</span><span class="p">))</span>
<span class="n">layer_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/layer.csv&quot;</span><span class="p">))</span>
<span class="n">layer_symmetry_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/layer_symmetry.csv&quot;</span><span class="p">))</span>
<span class="n">layer_generators_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/layer_generators.csv&quot;</span><span class="p">))</span>
<span class="n">rod_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/rod.csv&quot;</span><span class="p">))</span>
<span class="n">rod_symmetry_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/rod_symmetry.csv&quot;</span><span class="p">))</span>
<span class="n">rod_generators_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/rod_generators.csv&quot;</span><span class="p">))</span>
<span class="n">point_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/point.csv&quot;</span><span class="p">))</span>
<span class="n">point_symmetry_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/point_symmetry.csv&quot;</span><span class="p">))</span>
<span class="n">point_generators_df</span> <span class="o">=</span> <span class="n">read_csv</span><span class="p">(</span><span class="n">resource_filename</span><span class="p">(</span><span class="s2">&quot;pyxtal&quot;</span><span class="p">,</span> <span class="s2">&quot;database/point_generators.csv&quot;</span><span class="p">))</span>

<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="n">Identity</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)</span>
<span class="n">Inversion</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;-x,-y,-z&#39;</span><span class="p">)</span>
<span class="n">op_o</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,0&#39;</span><span class="p">)</span>
<span class="n">op_x</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,0,0&#39;</span><span class="p">)</span>
<span class="n">op_y</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,y,0&#39;</span><span class="p">)</span>
<span class="n">op_z</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,z&#39;</span><span class="p">)</span>

<span class="n">pglist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span><span class="s1">&#39;Ci&#39;</span><span class="p">,</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span><span class="s1">&#39;Cs&#39;</span><span class="p">,</span><span class="s1">&#39;C2h&#39;</span><span class="p">,</span><span class="s1">&#39;D2&#39;</span><span class="p">,</span><span class="s1">&#39;C2v&#39;</span><span class="p">,</span><span class="s1">&#39;D2h&#39;</span><span class="p">,</span>
    <span class="s1">&#39;C4&#39;</span><span class="p">,</span><span class="s1">&#39;S4&#39;</span><span class="p">,</span><span class="s1">&#39;C4h&#39;</span><span class="p">,</span><span class="s1">&#39;D4&#39;</span><span class="p">,</span><span class="s1">&#39;C4v&#39;</span><span class="p">,</span><span class="s1">&#39;D2d&#39;</span><span class="p">,</span><span class="s1">&#39;D4h&#39;</span><span class="p">,</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;C3i&#39;</span><span class="p">,</span><span class="s1">&#39;D3&#39;</span><span class="p">,</span><span class="s1">&#39;C3v&#39;</span><span class="p">,</span><span class="s1">&#39;D3d&#39;</span><span class="p">,</span><span class="s1">&#39;C6&#39;</span><span class="p">,</span><span class="s1">&#39;C3h&#39;</span><span class="p">,</span><span class="s1">&#39;C6h&#39;</span><span class="p">,</span><span class="s1">&#39;D6&#39;</span><span class="p">,</span>
    <span class="s1">&#39;C6v&#39;</span><span class="p">,</span><span class="s1">&#39;D3h&#39;</span><span class="p">,</span><span class="s1">&#39;D6h&#39;</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;Th&#39;</span><span class="p">,</span><span class="s1">&#39;O&#39;</span><span class="p">,</span><span class="s1">&#39;Td&#39;</span><span class="p">,</span><span class="s1">&#39;Oh&#39;</span><span class="p">]</span>

<span class="n">pgdict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="sd">&quot;&quot;&quot;Dict of crystallographic point group symbols and their corresponding numbers</span>
<span class="sd">(the number for initializing a Group object)&quot;&quot;&quot;</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pglist</span><span class="p">):</span>
    <span class="n">pgdict</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>

<span class="c1">#TODO: Add space, layer, and Rod group symbol lists</span>

<span class="c1">#Define functions</span>
<span class="c1">#------------------------------</span>
<div class="viewcode-block" id="list_point_groups"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.list_point_groups">[docs]</a><span class="k">def</span> <span class="nf">list_point_groups</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints out the numbers and symbols of the crystallographic point groups </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-- Point group numbers and symbols --&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pglist</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">sym</span><span class="p">)</span></div>

<div class="viewcode-block" id="symmetry_element_from_axis"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.symmetry_element_from_axis">[docs]</a><span class="k">def</span> <span class="nf">symmetry_element_from_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an axis, returns a SymmOp representing a symmetry element on the axis.</span>
<span class="sd">    For example, the symmetry element for the vector (0,0,2) would be (0,0,z).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        axis: a 3-vector representing the symmetry element</span>

<span class="sd">    Returns:</span>
<span class="sd">        a SymmOp object of form (ax, bx, cx), (ay, by, cy), or (az, bz, cz)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1">#Vector must be non-zero</span>
    <span class="k">if</span> <span class="n">dsquared</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1">#Find largest component (x, y, or z)</span>
    <span class="n">abs_vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">abs_vals</span><span class="p">)</span>
    <span class="n">index1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abs_vals</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="c1">#Initialize an affine matrix</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">m</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span>
    <span class="c1">#Set values for affine matrix</span>
    <span class="n">m</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">SymmOp</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></div>

<div class="viewcode-block" id="create_matrix"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.create_matrix">[docs]</a><span class="k">def</span> <span class="nf">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used for calculating distances in lattices with periodic boundary</span>
<span class="sd">    conditions. When multiplied with a set of points, generates additional</span>
<span class="sd">    points in cells adjacent to and diagonal to the original cell</span>

<span class="sd">    Args:</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array of matrices which can be multiplied by a set of</span>
<span class="sd">        coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">j_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">k_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">PBC</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">i_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">PBC</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">j_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">PBC</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">k_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_list</span><span class="p">:</span>
                <span class="n">matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>

<div class="viewcode-block" id="filtered_coords"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.filtered_coords">[docs]</a><span class="k">def</span> <span class="nf">filtered_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array of 3d fractional coordinates or a single 3d point, transform</span>
<span class="sd">    all coordinates to less than 1 and greater than 0. If one axis is not</span>
<span class="sd">    periodic, does not transform the coordinates along that axis. For example,</span>
<span class="sd">    for the point [1.2,1.6, -.4] with periodicity along the x and z axes, but</span>
<span class="sd">    not the y axis (PBC=[1,0,1]), the function would return [0.2, 1.6, 0.6].</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: an array of real 3d vectors. The shape does not matter</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        an array of filtered coords with the same shape as coords</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">filter_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vector</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">PBC</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">filter_vector</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="filtered_coords_euclidean"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.filtered_coords_euclidean">[docs]</a><span class="k">def</span> <span class="nf">filtered_coords_euclidean</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array of fractional 3-vectors, filters coordinates to between 0 and</span>
<span class="sd">    1. Then, values which are greater than 0.5 are converted to 1 minus their</span>
<span class="sd">    value. This is used for converting displacement vectors with a Euclidean</span>
<span class="sd">    lattice.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        coords: an array of real 3d vectors. The shape does not matter</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        an array of filtered coords with the same shape as coords</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">filter_vector_euclidean</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">vector</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">filter_vector_euclidean</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.distance">[docs]</a><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Euclidean distance from the origin for a fractional</span>
<span class="sd">    displacement vector. Takes into account the lattice metric and periodic</span>
<span class="sd">    boundary conditions, including up to one non-periodic axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        xyz: a fractional 3d displacement vector. Can be obtained by</span>
<span class="sd">            subtracting one fractional vector from another</span>
<span class="sd">        lattice: a 3x3 matrix describing a unit cell&#39;s lattice vectors</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        a scalar for the distance of the point from the origin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">+=</span> <span class="n">xyz</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">matrix</span><span class="p">,[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span>     </div>

<div class="viewcode-block" id="dsquared"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.dsquared">[docs]</a><span class="k">def</span> <span class="nf">dsquared</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the squared length of a 3-vector. Does not consider PBC.</span>

<span class="sd">    Args:</span>
<span class="sd">        v: a 3-vector</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        the squared length of the vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span></div>

<div class="viewcode-block" id="distance_matrix"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.distance_matrix">[docs]</a><span class="k">def</span> <span class="nf">distance_matrix</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the distances between two sets of fractional coordinates.</span>
<span class="sd">    Takes into account the lattice metric and periodic boundary conditions.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        points1: a list of fractional coordinates</span>
<span class="sd">        points2: another list of fractional coordinates</span>
<span class="sd">        lattice: a 3x3 matrix describing a unit cell&#39;s lattice vectors</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">        metric: the metric to use with cdist. Possible values include &#39;euclidean&#39;,</span>
<span class="sd">            &#39;sqeuclidean&#39;, &#39;minkowski&#39;, and others</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 2x2 np array of scalar distances</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span> <span class="o">==</span> <span class="n">Euclidean_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">points2</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">l1</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">])</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="n">all_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cdist</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">m1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">all_distances</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cdist</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">points2</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">l1</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">])</span>
            <span class="n">all_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cdist</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">m1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">all_distances</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cdist</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance_matrix_euclidean"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.distance_matrix_euclidean">[docs]</a><span class="k">def</span> <span class="nf">distance_matrix_euclidean</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the distances between two sets of fractional coordinates.</span>
<span class="sd">    Takes into account periodic boundary conditions, but assumes a Euclidean matrix.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        points1: a list of fractional coordinates</span>
<span class="sd">        points2: another list of fractional coordinates</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">        squared: whether to return the squared distance (True) or the Euclidean distance (False)</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 2x2 np array of scalar distances</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">points2</span> <span class="o">-</span> <span class="n">p</span>
    <span class="c1">#get displacement vectors</span>
    <span class="n">displacements</span> <span class="o">=</span> <span class="n">filtered_coords_euclidean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">subtract</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">points1</span><span class="p">),</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="c1">#Calculate norms</span>
    <span class="k">if</span> <span class="n">squared</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">dsquared</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">displacements</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">displacements</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_wyckoffs"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_wyckoffs">[docs]</a><span class="k">def</span> <span class="nf">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given space group. Has option to</span>
<span class="sd">    organize the list based on multiplicity (this is used for</span>
<span class="sd">    random_crystal.wyckoffs) For an unorganized list:</span>

<span class="sd">    1st index: index of WP in sg (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For an organized list:</span>

<span class="sd">    1st index: specifies multiplicity (0 is the largest multiplicity)</span>

<span class="sd">    2nd index: corresponds to a Wyckoff position within the group of equal</span>
<span class="sd">        multiplicity.</span>

<span class="sd">    3nd index: corresponds to a SymmOp object within the Wyckoff position</span>

<span class="sd">    You may switch between organized and unorganized lists using the methods</span>
<span class="sd">    i_from_jk and jk_from_i. For example, if a Wyckoff position is the [i]</span>
<span class="sd">    entry in an unorganized list, it will be the [j][k] entry in an organized</span>
<span class="sd">    list.</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>

    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wyckoff_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">coor1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
            <span class="n">invalid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coor1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                        <span class="c1">#invalid wyckoffs for layer group</span>
                        <span class="n">invalid</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">invalid</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_layer"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_layer">[docs]</a><span class="k">def</span> <span class="nf">get_layer</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given 2D layer group. Has</span>
<span class="sd">    option to organize the list based on multiplicity (this is used for</span>
<span class="sd">    random_crystal_2D.wyckoffs) For an unorganized list:</span>

<span class="sd">    1st index: index of WP in layer group (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For an organized list:</span>

<span class="sd">    1st index: specifies multiplicity (0 is the largest multiplicity)</span>

<span class="sd">    2nd index: corresponds to a Wyckoff position within the group of equal</span>
<span class="sd">        multiplicity.</span>

<span class="sd">    3nd index: corresponds to a SymmOp object within the Wyckoff position</span>

<span class="sd">    You may switch between organized and unorganized lists using the methods</span>
<span class="sd">    i_from_jk and jk_from_i. For example, if a Wyckoff position is the [i]</span>
<span class="sd">    entry in an unorganized list, it will be the [j][k] entry in an organized</span>
<span class="sd">    list.</span>

<span class="sd">    For layer groups with more than one possible origin, origin choice 2 is</span>
<span class="sd">    used.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the international layer group number</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">layer_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_rod"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_rod">[docs]</a><span class="k">def</span> <span class="nf">get_rod</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given 1D Rod group. Has option to</span>
<span class="sd">    organize the list based on multiplicity (this is used for</span>
<span class="sd">    random_crystal_1D.wyckoffs) For an unorganized list:</span>

<span class="sd">    1st index: index of WP in layer group (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For an organized list:</span>

<span class="sd">    1st index: specifies multiplicity (0 is the largest multiplicity)</span>

<span class="sd">    2nd index: corresponds to a Wyckoff position within the group of equal</span>
<span class="sd">        multiplicity.</span>

<span class="sd">    3nd index: corresponds to a SymmOp object within the Wyckoff position</span>

<span class="sd">    You may switch between organized and unorganized lists using the methods</span>
<span class="sd">    i_from_jk and jk_from_i. For example, if a Wyckoff position is the [i]</span>
<span class="sd">    entry in an unorganized list, it will be the [j][k] entry in an organized</span>
<span class="sd">    list.</span>

<span class="sd">    For Rod groups with more than one possible setting, setting choice 1</span>
<span class="sd">    is used.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the international Rod group number</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">rod_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_point"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_point">[docs]</a><span class="k">def</span> <span class="nf">get_point</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">organized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff positions for a given crystallographic point group.</span>
<span class="sd">    Has option to organize the list based on multiplicity.</span>

<span class="sd">    1st index: index of WP in layer group (0 is the WP with largest multiplicity)</span>

<span class="sd">    2nd index: a SymmOp object in the WP</span>

<span class="sd">    For point groups except T, Th, O, Td, and Oh, unique axis z is used.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the point group number (see bottom of source code for a list)</span>
<span class="sd">        organized: whether or not to organize the list based on multiplicity</span>
<span class="sd">        molecular: whether or not to convert to Euclidean reference frame</span>
<span class="sd">            (for hexagonal lattices: point groups 16-27)</span>
<span class="sd">    </span>
<span class="sd">    Returns: </span>
<span class="sd">        a list of Wyckoff positions, each of which is a list of SymmOp&#39;s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">28</span><span class="p">):</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">wyckoff_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">point_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wyckoff_strings</span><span class="p">:</span>
        <span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>

            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
            <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">organized</span><span class="p">:</span>
        <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
            <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wyckoffs_organized</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wyckoffs</span></div>

<div class="viewcode-block" id="get_wyckoff_symmetry"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_wyckoff_symmetry">[docs]</a><span class="k">def</span> <span class="nf">get_wyckoff_symmetry</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff position site symmetry for a given space group.</span>
<span class="sd">    1st index: index of WP in sg (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a point within the WP</span>
<span class="sd">    3rd index: a site symmetry SymmOp of the point</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3d list of SymmOp objects representing the site symmetry of each</span>
<span class="sd">        point in each Wyckoff position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">symmetry_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wyckoff_symmetry_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">])</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&gt;=</span> <span class="mi">143</span> <span class="ow">and</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symmetry_strings</span><span class="p">,</span> <span class="n">wyckoffs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coor1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
            <span class="n">invalid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coor1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                        <span class="n">invalid</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">invalid</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="c1">#Loop over points in WP</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="c1">#Loop over ops</span>
                    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                        <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#Loop over points in WP</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="c1">#Loop over ops</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="get_layer_symmetry"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_layer_symmetry">[docs]</a><span class="k">def</span> <span class="nf">get_layer_symmetry</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff position site symmetry for a given space group.</span>
<span class="sd">    1st index: index of WP in group (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a point within the WP</span>
<span class="sd">    3rd index: a site symmetry SymmOp of the point</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the layer group number</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3d list of SymmOp objects representing the site symmetry of each</span>
<span class="sd">        point in each Wyckoff position</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">symmetry_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">layer_symmetry_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">65</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symmetry_strings</span><span class="p">:</span>
        <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Loop over points in WP</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#Loop over ops</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="get_rod_symmetry"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_rod_symmetry">[docs]</a><span class="k">def</span> <span class="nf">get_rod_symmetry</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff position site symmetry for a given Rod group.</span>
<span class="sd">    1st index: index of WP in group (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a point within the WP</span>
<span class="sd">    3rd index: a site symmetry SymmOp of the point</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the Rod group number</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3d list of SymmOp objects representing the site symmetry of each</span>
<span class="sd">        point in each Wyckoff position</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">symmetry_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">rod_symmetry_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">42</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symmetry_strings</span><span class="p">:</span>
        <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Loop over points in WP</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#Loop over ops</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="get_point_symmetry"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_point_symmetry">[docs]</a><span class="k">def</span> <span class="nf">get_point_symmetry</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff position site symmetry for a given point group.</span>
<span class="sd">    1st index: index of WP in group (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a point within the WP</span>
<span class="sd">    3rd index: a site symmetry SymmOp of the point</span>

<span class="sd">    Args:</span>
<span class="sd">        num: the point group number</span>
<span class="sd">        molecular: whether or not to convert to Euclidean reference frame</span>
<span class="sd">            (for hexagonal lattices: point groups 16-27)</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3d list of SymmOp objects representing the site symmetry of each</span>
<span class="sd">        point in each Wyckoff position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">symmetry_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">point_symmetry_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">28</span><span class="p">):</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symmetry_strings</span><span class="p">:</span>
        <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Loop over points in WP</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#Loop over ops</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">symmetry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="get_wyckoff_generators"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_wyckoff_generators">[docs]</a><span class="k">def</span> <span class="nf">get_wyckoff_generators</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff generators for a given space group.</span>
<span class="sd">    1st index: index of WP in sg (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a generator for the WP</span>
<span class="sd">    This function is useful for rotating molecules based on Wyckoff position,</span>
<span class="sd">    since special Wyckoff positions only encode positional information, but not</span>
<span class="sd">    information about the orientation. The generators for each Wyckoff position</span>
<span class="sd">    form a subset of the spacegroup&#39;s general Wyckoff position.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a 2d list of SymmOp objects which can be used to generate a Wyckoff position given a</span>
<span class="sd">        single fractional (x,y,z) coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">generator_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wyckoff_generators_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">])</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&gt;=</span> <span class="mi">143</span> <span class="ow">and</span> <span class="n">sg</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">generator_strings</span><span class="p">,</span> <span class="n">wyckoffs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">PBC</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coor1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
            <span class="n">invalid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coor1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                        <span class="n">invalid</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">invalid</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="c1">#Loop over ops</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
                <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generators</span></div>

<div class="viewcode-block" id="get_layer_generators"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_layer_generators">[docs]</a><span class="k">def</span> <span class="nf">get_layer_generators</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff generators for a given layer group.</span>
<span class="sd">    1st index: index of WP in group (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a generator for the WP</span>
<span class="sd">    This function is useful for rotating molecules based on Wyckoff position,</span>
<span class="sd">    since special Wyckoff positions only encode positional information, but not</span>
<span class="sd">    information about the orientation. The generators for each Wyckoff position</span>
<span class="sd">    form a subset of the group&#39;s general Wyckoff position.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        num: the layer group number</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a 2d list of SymmOp objects which can be used to generate a Wyckoff position given a</span>
<span class="sd">        single fractional (x,y,z) coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">generator_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">layer_generators_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">65</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">generator_strings</span><span class="p">:</span>
        <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Loop over ops</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
            <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generators</span></div>

<div class="viewcode-block" id="get_rod_generators"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_rod_generators">[docs]</a><span class="k">def</span> <span class="nf">get_rod_generators</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff generators for a given Rod group.</span>
<span class="sd">    1st index: index of WP in group (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a generator for the WP</span>
<span class="sd">    This function is useful for rotating molecules based on Wyckoff position,</span>
<span class="sd">    since special Wyckoff positions only encode positional information, but not</span>
<span class="sd">    information about the orientation. The generators for each Wyckoff position</span>
<span class="sd">    form a subset of the group&#39;s general Wyckoff position.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        num: the Rod group number</span>
<span class="sd">        molecular: whether or not to return the Euclidean point symmetry</span>
<span class="sd">            operations. If True, cuts off translational part of operation, and</span>
<span class="sd">            converts non-orthogonal operations (3-fold and 6-fold rotations)</span>
<span class="sd">            to (orthogonal) pure rotations. Should be used when dealing with</span>
<span class="sd">            molecular crystals</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a 2d list of SymmOp objects which can be used to generate a Wyckoff position given a</span>
<span class="sd">        single fractional (x,y,z) coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">generator_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">rod_generators_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">42</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">generator_strings</span><span class="p">:</span>
        <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Loop over ops</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
            <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generators</span></div>

<div class="viewcode-block" id="get_point_generators"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.get_point_generators">[docs]</a><span class="k">def</span> <span class="nf">get_point_generators</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Wyckoff generators for a given point group.</span>
<span class="sd">    1st index: index of WP in group (0 is the WP with largest multiplicity)</span>
<span class="sd">    2nd index: a generator for the WP</span>
<span class="sd">    This function is useful for rotating molecules based on Wyckoff position,</span>
<span class="sd">    since special Wyckoff positions only encode positional information, but not</span>
<span class="sd">    information about the orientation. The generators for each Wyckoff position</span>
<span class="sd">    form a subset of the group&#39;s general Wyckoff position.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        num: the Rod group number</span>
<span class="sd">        molecular: whether or not to convert to Euclidean reference frame</span>
<span class="sd">            (for hexagonal lattices: point groups 16-27)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a 2d list of SymmOp objects which can be used to generate a Wyckoff position given a</span>
<span class="sd">        single fractional (x,y,z) coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">generator_strings</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">point_generators_df</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">][</span><span class="n">num</span><span class="p">])</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">28</span><span class="p">):</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">generator_strings</span><span class="p">:</span>
        <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Loop over ops</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1">#Convert non-orthogonal trigonal/hexagonal operations</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inverse</span>
            <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">generators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generators</span></div>

<div class="viewcode-block" id="general_position"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.general_position">[docs]</a><span class="k">def</span> <span class="nf">general_position</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a Wyckoff_position object for the general Wyckoff position of the given</span>
<span class="sd">    group.</span>

<span class="sd">    Args:</span>
<span class="sd">        number: the international number of the group</span>
<span class="sd">        dim: the dimension of the group 3: space group, 2: layer group, 1: Rod group</span>

<span class="sd">    Returns:</span>
<span class="sd">        a Wyckoff_position object for the general position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Wyckoff_position</span><span class="o">.</span><span class="n">from_group_and_index</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span></div>

<div class="viewcode-block" id="site_symm"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.site_symm">[docs]</a><span class="k">def</span> <span class="nf">site_symm</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">Euclidean_lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point and a general Wyckoff position, return the list of symmetry</span>
<span class="sd">    operations leaving the point (coordinate or SymmOp) invariant. The returned</span>
<span class="sd">    SymmOps are a subset of the general position. The site symmetry can be used</span>
<span class="sd">    for determining the Wyckoff position for a set of points, or for</span>
<span class="sd">    determining the valid orientations of a molecule within a given Wyckoff</span>
<span class="sd">    position.</span>

<span class="sd">    Args:</span>
<span class="sd">        point: a 1x3 coordinate or SymmOp object to find the symmetry of. If a</span>
<span class="sd">            SymmOp is given, the returned symmetries must also preserve the</span>
<span class="sd">            point&#39;s orientaion</span>
<span class="sd">        gen_pos: the general position of the spacegroup. Can be a Wyckoff_position</span>
<span class="sd">            object or list of SymmOp objects.</span>
<span class="sd">            Can be obtained using general_position()</span>
<span class="sd">        tol:</span>
<span class="sd">            the numberical tolerance for determining equivalent positions and</span>
<span class="sd">            orientations.</span>
<span class="sd">        lattice:</span>
<span class="sd">            a 3x3 matrix representing the lattice vectors of the unit cell</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis.</span>
<span class="sd">            Need not be defined here if gen_pos is a Wyckoff_position object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of SymmOp objects which leave the given point invariant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gen_pos</span><span class="p">)</span> <span class="o">==</span> <span class="n">Wyckoff_position</span><span class="p">:</span>
            <span class="n">PBC</span> <span class="o">=</span> <span class="n">gen_pos</span><span class="o">.</span><span class="n">PBC</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#Convert point into a SymmOp</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SymmOp</span><span class="p">:</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">gen_pos</span><span class="p">:</span>
        <span class="n">is_symmetry</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#Calculate the effect of applying op to point</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="p">((</span><span class="n">op</span><span class="o">*</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">affine_matrix</span> <span class="o">-</span> <span class="n">point</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">)</span>
        <span class="c1">#Check that the rotation matrix is unaltered by op</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">difference</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
            <span class="n">is_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#Check that the displacement is less than tol</span>
        <span class="n">displacement</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">translation_vector</span>
        <span class="k">if</span> <span class="n">distance</span><span class="p">(</span><span class="n">displacement</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">is_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">is_symmetry</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;The actual site symmetry&#39;s translation vector may vary from op by</span>
<span class="sd">            a factor of +1 or -1 (especially when op contains +-1/2).</span>
<span class="sd">            We record this to distinguish between special Wyckoff positions.</span>
<span class="sd">            As an example, consider the point (-x+1/2,-x,x+1/2) in position 16c</span>
<span class="sd">            of space group Ia-3(206). The site symmetry includes the operations</span>
<span class="sd">            (-z+1,x-1/2,-y+1/2) and (y+1/2,-z+1/2,-x+1). These operations are</span>
<span class="sd">            not listed in the general position, but correspond to the operations</span>
<span class="sd">            (-z,x+1/2,-y+1/2) and (y+1/2,-z+1/2,-x), respectively, just shifted</span>
<span class="sd">            by (+1,-1,0) and (0,0,+1), respectively.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">translation_vector</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">displacement</span><span class="p">))</span>
            <span class="n">symmetry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>

<div class="viewcode-block" id="find_generating_point"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.find_generating_point">[docs]</a><span class="k">def</span> <span class="nf">find_generating_point</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">wyckoff_position</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of coordinates and Wyckoff generators, return the coord which</span>
<span class="sd">    can be used to generate the others. This is useful for molecular Wyckoff</span>
<span class="sd">    positions, for which the orientation, and not just the position, is</span>
<span class="sd">    needed for each point in the Wyckoff position. Thus, we need to know which</span>
<span class="sd">    coordinates to use for x, y, and z, so that rotations can be applied</span>
<span class="sd">    correctly using the Wyckoff geneators</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: a list of fractional coordinates corresponding to a Wyckoff</span>
<span class="sd">            position</span>
<span class="sd">        wyckoff_position: a Wyckoff_position object</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a fractional coordinate [x, y, z] corresponding to the first listed</span>
<span class="sd">        point in the Wyckoff position</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="n">wyckoff_position</span><span class="o">.</span><span class="n">generators</span>
    <span class="n">PBC</span> <span class="o">=</span> <span class="n">wyckoff_position</span><span class="o">.</span><span class="n">PBC</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">generators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
            <span class="k">continue</span>
        <span class="n">tmp_c</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">tmp_c</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">generated</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">)</span>
        <span class="n">generated</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">generated</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">index_list1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">)))</span>
        <span class="n">index_list2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generated</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">generated</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">):</span>
            <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Warning: coordinate and generator lists have unequal length.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span><span class="s2">&quot;In check_wyckoff_position.find_generating_point:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span><span class="s2">&quot;len(coords): &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;, len(generators): &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">generators</span><span class="p">)),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tmp_c</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">generated</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=.</span><span class="mi">001</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=.</span><span class="mi">001</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index1</span> <span class="ow">in</span> <span class="n">index_list1</span> <span class="ow">and</span> <span class="n">index2</span> <span class="ow">in</span> <span class="n">index_list2</span><span class="p">:</span>
                        <span class="n">index_list1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span>
                        <span class="n">index_list2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="n">index_list2</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">coord</span>
    <span class="c1">#If no valid coordinate is found</span>
    <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="check_wyckoff_position"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.check_wyckoff_position">[docs]</a><span class="k">def</span> <span class="nf">check_wyckoff_position</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of points, returns a single index of a matching Wyckoff</span>
<span class="sd">    position in the space group. Checks the site symmetry of each supplied</span>
<span class="sd">    point against the site symmetry for each point in the Wyckoff position.</span>
<span class="sd">    Also returns a point which can be used to generate the rest using the</span>
<span class="sd">    Wyckoff position operators</span>

<span class="sd">    Args:</span>
<span class="sd">        points: a list of 3d coordinates or SymmOps to check</span>
<span class="sd">        group: a Group object</span>
<span class="sd">        tol: the max distance between equivalent points</span>

<span class="sd">    Returns:</span>
<span class="sd">        index, p: index is a single index for the Wyckoff position within</span>
<span class="sd">        the sg. If no matching WP is found, returns False. point is a</span>
<span class="sd">        coordinate taken from the list points. When plugged into the Wyckoff</span>
<span class="sd">        position, it will generate all the other points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">wyckoffs</span>
    <span class="n">w_symm_all</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">w_symm</span>
    <span class="n">PBC</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">PBC</span>
    <span class="c1">#new method</span>
    <span class="c1">#Store the squared distance tolerance</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">tol</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1">#Loop over Wyckoff positions</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">):</span>
        <span class="c1">#Check that length of points and wp are equal</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">):</span> <span class="k">continue</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#Search for a generating point</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#Check that point works as x,y,z value for wp</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">filtered_coords_euclidean</span><span class="p">(</span><span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dsquared</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1">#Calculate distances between original and generated points</span>
            <span class="n">pw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">wp</span><span class="p">])</span>
            <span class="n">dw</span> <span class="o">=</span> <span class="n">distance_matrix_euclidean</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">#Check each row for a zero</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dw</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">failed</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1">#Check each column for a zero</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">dw</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">column</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="c1">#Calculate distance between original and generated points</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">w_symm_all</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">distance_matrix_euclidean</span><span class="p">([</span><span class="n">p</span><span class="p">],</span> <span class="n">ps</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1">#Check whether any generated points are too far away</span>
            <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">ds</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">failed</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span></div>

<span class="c1">#TODO: Use Group object instead of organized array</span>
<div class="viewcode-block" id="letter_from_index"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.letter_from_index">[docs]</a><span class="k">def</span> <span class="nf">letter_from_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a Wyckoff position&#39;s index within a spacegroup, return its number</span>
<span class="sd">    and letter e.g. &#39;4a&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        index: a single integer describing the WP&#39;s index within the</span>
<span class="sd">            spacegroup (0 is the general position)</span>
<span class="sd">        arr: an unorganized Wyckoff position array</span>
<span class="sd">   </span>
<span class="sd">    Returns:</span>
<span class="sd">        the Wyckoff letter corresponding to the Wyckoff position (for example,</span>
<span class="sd">        for position 4a, the function would return &#39;a&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">letters</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="index_from_letter"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.index_from_letter">[docs]</a><span class="k">def</span> <span class="nf">index_from_letter</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the Wyckoff letter, returns the index of a Wyckoff position within</span>
<span class="sd">    the spacegroup</span>

<span class="sd">    Args:</span>
<span class="sd">        letter: The wyckoff letter</span>
<span class="sd">        arr: an unorganized Wyckoff position array</span>

<span class="sd">    Returns:</span>
<span class="sd">        a single index specifying the location of the Wyckoff position within</span>
<span class="sd">        the spacegroup (0 is the general position)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">letters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span></div>

<div class="viewcode-block" id="jk_from_i"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.jk_from_i">[docs]</a><span class="k">def</span> <span class="nf">jk_from_i</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">olist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an organized list (Wyckoff positions or orientations), determine the</span>
<span class="sd">    two indices which correspond to a single index for an unorganized list.</span>
<span class="sd">    Used mainly for organized Wyckoff position lists, but can be used for other</span>
<span class="sd">    lists organized in a similar way</span>

<span class="sd">    Args:</span>
<span class="sd">        i: a single index corresponding to the item&#39;s location in the</span>
<span class="sd">            unorganized list</span>
<span class="sd">        olist: the organized list</span>

<span class="sd">    Returns:</span>
<span class="sd">        [j, k]: two indices corresponding to the item&#39;s location in the</span>
<span class="sd">            organized list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">j</span> <span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">olist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
    <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Incorrect Wyckoff position list or index passed to jk_from_i&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="i_from_jk"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.i_from_jk">[docs]</a><span class="k">def</span> <span class="nf">i_from_jk</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">olist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse operation of jk_from_i: gives one list index from 2</span>

<span class="sd">    Args:</span>
<span class="sd">        j, k: indices corresponding to the location of an element in the</span>
<span class="sd">            organized list</span>
<span class="sd">        olist: the organized list of Wyckoff positions or molecular orientations</span>

<span class="sd">    Returns:</span>
<span class="sd">        i: one index corresponding to the item&#39;s location in the</span>
<span class="sd">            unorganized list    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">olist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span>
    <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Incorrect Wyckoff position list or index passed to jk_from_i&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ss_string_from_ops"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.ss_string_from_ops">[docs]</a><span class="k">def</span> <span class="nf">ss_string_from_ops</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the Hermann-Mauguin symbol for a site symmetry group, using a list of</span>
<span class="sd">    SymmOps as input. Note that the symbol does not necessarily refer to the</span>
<span class="sd">    x,y,z axes. For information on reading these symbols, see:</span>
<span class="sd">    http://en.wikipedia.org/wiki/Hermann-Mauguin_notation#Point_groups</span>

<span class="sd">    Args:</span>
<span class="sd">        ops: a list of SymmOp objects representing the site symmetry</span>
<span class="sd">        number: International number of the symmetry group. Used to determine which</span>
<span class="sd">            axes to show. For example, a 3-fold rotation in a cubic system is</span>
<span class="sd">            written as &quot;.3.&quot;, whereas a 3-fold rotation in a trigonal system is</span>
<span class="sd">            written as &quot;3..&quot;</span>
<span class="sd">        dim: the dimension of the crystal. Also used to determine notation type</span>
<span class="sd">        complete: whether or not all symmetry operations in the group</span>
<span class="sd">            are present. If False, we generate the rest</span>

<span class="sd">    Returns:</span>
<span class="sd">        a string representing the site symmetry. Ex: &quot;2mm&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: Automatically detect which symm_type to use based on ops</span>
    <span class="c1">#Determine which notation to use</span>
    <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;high&quot;</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">74</span><span class="p">:</span>
            <span class="c1">#Triclinic, monoclinic, orthorhombic</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;low&quot;</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">75</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
            <span class="c1">#Trigonal, Hexagonal, Tetragonal</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;medium&quot;</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">195</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">230</span><span class="p">:</span>
            <span class="c1">#cubic</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;high&quot;</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">48</span><span class="p">:</span>
            <span class="c1">#Triclinic, monoclinic, orthorhombic</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;low&quot;</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">49</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">80</span><span class="p">:</span>
            <span class="c1">#Trigonal, Hexagonal, Tetragonal</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;medium&quot;</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">22</span><span class="p">:</span>
            <span class="c1">#Triclinic, monoclinic, orthorhombic</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;low&quot;</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="o">&gt;=</span> <span class="mi">23</span> <span class="ow">and</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">75</span><span class="p">:</span>
            <span class="c1">#Trigonal, Hexagonal, Tetragonal</span>
            <span class="n">symm_type</span> <span class="o">=</span> <span class="s2">&quot;medium&quot;</span>

    <span class="c1">#TODO: replace sg with number, add dim variable</span>
    <span class="c1">#Return the symbol for a single axis</span>
    <span class="c1">#Will be called later in the function</span>
    <span class="k">def</span> <span class="nf">get_symbol</span><span class="p">(</span><span class="n">opas</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">has_reflection</span><span class="p">):</span>
        <span class="c1">#ops: a list of Symmetry operations about the axis</span>
        <span class="c1">#order: highest order of any symmetry operation about the axis</span>
        <span class="c1">#has_reflection: whether or not the axis has mirror symmetry</span>
        <span class="k">if</span> <span class="n">has_reflection</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#rotations have priority</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotation&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/m&quot;</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotoinversion&quot;</span>
                    <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">return</span> <span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;m&quot;</span>
        <span class="k">elif</span> <span class="n">has_reflection</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1">#rotoinversion has priority</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotoinversion&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotation&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">rotation_order</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;.&quot;</span>
    <span class="c1">#Given a list of single-axis symbols, return the one with highest symmetry</span>
    <span class="c1">#Will be called later in the function</span>
    <span class="k">def</span> <span class="nf">get_highest_symbol</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="n">symbol_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;2&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;-2&#39;</span><span class="p">,</span><span class="s1">&#39;2/m&#39;</span><span class="p">,</span><span class="s1">&#39;3&#39;</span><span class="p">,</span><span class="s1">&#39;4&#39;</span><span class="p">,</span><span class="s1">&#39;-4&#39;</span><span class="p">,</span><span class="s1">&#39;4/m&#39;</span><span class="p">,</span><span class="s1">&#39;-3&#39;</span><span class="p">,</span><span class="s1">&#39;6&#39;</span><span class="p">,</span><span class="s1">&#39;-6&#39;</span><span class="p">,</span><span class="s1">&#39;6/m&#39;</span><span class="p">]</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">use_list</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbol_list</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">symbol_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_list</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">num_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">symbol</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">())</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_str</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;m&#39;</span> <span class="ow">in</span> <span class="n">symbol</span> <span class="ow">or</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">symbol</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">i1</span>
                    <span class="k">elif</span> <span class="n">i1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                <span class="n">max_j</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">use_list</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol_list</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbols</span><span class="p">[</span><span class="n">max_j</span><span class="p">]</span>
        
    <span class="c1">#Return whether or not two axes are symmetrically equivalent</span>
    <span class="c1">#It is assumed that both axes possess the same symbol</span>
    <span class="c1">#Will be called within combine_axes</span>
    <span class="k">def</span> <span class="nf">are_symmetrically_equivalent</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">):</span>
        <span class="n">axis1</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>
        <span class="n">axis2</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span>
        <span class="n">condition1</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">condition2</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#Check for an operation mapping one axis onto the other</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">condition1</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">condition2</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">new1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
                <span class="n">new2</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">condition1</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new2</span><span class="p">,</span> <span class="n">axis1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">condition2</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">condition1</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">condition2</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="c1">#Given a list of axis indices, return the combined symbol</span>
    <span class="c1">#Axes may or may not be symmetrically equivalent, but must be of the same</span>
    <span class="c1">#type (x/y/z, face-diagonal, body-diagonal)</span>
    <span class="c1">#Will be called for mid- and high-symmetry crystallographic point groups</span>
    <span class="k">def</span> <span class="nf">combine_axes</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">orders</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">reflections</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symbols</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="s2">&quot;.&quot;</span>
        <span class="c1">#Remove redundant axes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">symbols</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">are_symmetrically_equivalent</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                                <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="c1">#Combine symbols for non-equivalent axes</span>
        <span class="n">new_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">new_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">while</span> <span class="n">new_symbols</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">highest</span> <span class="o">=</span> <span class="n">get_highest_symbol</span><span class="p">(</span><span class="n">new_symbols</span><span class="p">)</span>
            <span class="n">symbol</span> <span class="o">+=</span> <span class="n">highest</span>
            <span class="n">new_symbols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">highest</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: could not combine site symmetry axes.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
    <span class="c1">#Generate needed ops</span>
    <span class="k">if</span> <span class="n">complete</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">generate_full_symmops</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span>
    <span class="c1">#Get OperationAnalyzer object for all ops</span>
    <span class="n">opas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">opas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">OperationAnalyzer</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
    <span class="c1">#Store the symmetry of each axis</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[[],[],[],[],[],[],[],[],[],[],[],[],[]]</span>
    <span class="n">has_inversion</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#Store possible symmetry axes for crystallographic point groups</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">opas</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;identity&quot;</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;inversion&quot;</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opa</span><span class="p">)</span>
            <span class="c1">#Store uncommon axes for trigonal and hexagonal lattices</span>
            <span class="k">if</span> <span class="n">found</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opa</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
                <span class="c1">#Check that new axis is not symmetrically equivalent to others</span>
                <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">are_symmetrically_equivalent</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">unique</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">opa</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">unique</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;inversion&quot;</span><span class="p">:</span>
            <span class="n">has_inversion</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#Determine how many high-symmetry axes are present</span>
    <span class="n">n_axes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#Store the order of each axis</span>
    <span class="n">orders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#Store whether or not each axis has reflection symmetry</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">high_symm</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">has_reflection</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">opa</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">high_symm</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">order</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span>
            <span class="k">if</span> <span class="n">opa</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">opa</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;rotoinversion&quot;</span><span class="p">:</span>
                <span class="n">has_reflection</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">high_symm</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_axes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">reflections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">has_reflection</span><span class="p">)</span>
    <span class="c1">#Triclinic, monoclinic, orthorhombic</span>
    <span class="c1">#Positions in symbol refer to x,y,z axes respectively</span>
    <span class="k">if</span> <span class="n">symm_type</span> <span class="o">==</span> <span class="s2">&quot;low&quot;</span><span class="p">:</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>
                <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;...&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;...&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-1&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
    <span class="c1">#Trigonal, Hexagonal, Tetragonal</span>
    <span class="k">elif</span> <span class="n">symm_type</span> <span class="o">==</span> <span class="s2">&quot;medium&quot;</span><span class="p">:</span>
        <span class="c1">#1st symbol: z axis</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">get_symbol</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reflections</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1">#2nd symbol: x or y axes (whichever have higher symmetry)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#3rd symbol: face-diagonal axes (whichever have highest symmetry)</span>
        <span class="n">s3</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">))))</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">s1</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s2</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s3</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-1&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
    <span class="c1">#Cubic</span>
    <span class="k">elif</span> <span class="n">symm_type</span> <span class="o">==</span> <span class="s2">&quot;high&quot;</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#1st symbol: x, y, and/or z axes (whichever have highest symmetry)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1">#2nd symbol: body-diagonal axes (whichever has highest symmetry)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
        <span class="c1">#3rd symbol: face-diagonal axes (whichever have highest symmetry)</span>
        <span class="n">s3</span> <span class="o">=</span> <span class="n">combine_axes</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">s1</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s2</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">s3</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;. . .&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-1&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid spacegroup number&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="symbol_from_number"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.symbol_from_number">[docs]</a><span class="k">def</span> <span class="nf">symbol_from_number</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the H-M symbol for a given international group number</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: Create database/lists of symbols for groups</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="organized_wyckoffs"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.organized_wyckoffs">[docs]</a><span class="k">def</span> <span class="nf">organized_wyckoffs</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a Group object or unorganized list of Wyckoff positions and returns</span>
<span class="sd">    a 2D list of Wyckoff positions organized by multiplicity.</span>

<span class="sd">    Args:</span>
<span class="sd">        group: a pyxtal.symmetry.Group object</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a 2D list of Wyckoff_position objects if group is a Group object.</span>
<span class="sd">        a 3D list of SymmOp objects if group is a 2D list of SymmOps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="n">Group</span><span class="p">:</span>
        <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">Wyckoff_positions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">group</span>
    <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="c1">#2D Array of WP&#39;s organized by multiplicity</span>
    <span class="n">old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wyckoffs</span><span class="p">:</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>
            <span class="n">wyckoffs_organized</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">mult</span>
        <span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wyckoffs_organized</span></div>

<div class="viewcode-block" id="Wyckoff_position"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Wyckoff_position">[docs]</a><span class="k">class</span> <span class="nc">Wyckoff_position</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for a single Wyckoff position within a symmetry group</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Wyckoff_position.from_dict"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Wyckoff_position.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a Wyckoff_position object using a dictionary. Used mainly by the</span>
<span class="sd">        Wyckoff class for constructing a list of Wyckoff_position objects at once</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wp</span> <span class="o">=</span> <span class="n">Wyckoff_position</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">wp</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
                <span class="k">return</span> <span class="s2">&quot;Error: invalid crystal dimension. Must be a number between 0 and 3.&quot;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Wyckoff position &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">letter</span><span class="o">+</span><span class="s2">&quot; in &quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;space &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;layer &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;Rod &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;Point group &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;group &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; with site symmetry &quot;</span><span class="o">+</span><span class="n">ss_string_from_ops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetry_m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">op</span><span class="o">.</span><span class="n">as_xyz_string</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Wyckoff_position.from_group_and_index"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Wyckoff_position.from_group_and_index">[docs]</a>    <span class="k">def</span> <span class="nf">from_group_and_index</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Wyckoff_position using the space group number and index</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            group: the international number of the symmetry group</span>
<span class="sd">            index: the index or letter of the Wyckoff position within the group.</span>
<span class="sd">                0 is always the general position, and larger indeces represent positions</span>
<span class="sd">                with lower multiplicity. Alternatively, index can be the Wyckoff letter</span>
<span class="sd">                (&quot;4a6&quot; or &quot;f&quot;)</span>
<span class="sd">            dim: the periodic dimension of the crystal</span>
<span class="sd">            PBC: the periodic boundary conditions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wp</span> <span class="o">=</span> <span class="n">Wyckoff_position</span><span class="p">()</span>
        <span class="n">wp</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">group</span>
            <span class="n">number</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#TODO: add symbol interpretation</span>
            <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: must use an integer group number.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">use_letter</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">use_letter</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1">#Extract letter from number-letter combinations (&quot;4d&quot;-&gt;&quot;d&quot;)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">231</span><span class="p">):</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="n">PBC</span>
            <span class="n">ops_all</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_letter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index_from_letter</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">ops_all</span><span class="p">)</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">letter_from_index</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ops_all</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops_all</span><span class="p">)</span> <span class="ow">or</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error while generating Wyckoff_position: index out of range for specified group&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops_all</span><span class="p">[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">get_wyckoff_symmetry</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">symmetry_m</span> <span class="o">=</span> <span class="n">get_wyckoff_symmetry</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">generators</span> <span class="o">=</span> <span class="n">get_wyckoff_generators</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">generators_m</span> <span class="o">=</span> <span class="n">get_wyckoff_generators</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">81</span><span class="p">):</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="n">PBC</span>
            <span class="n">ops_all</span> <span class="o">=</span> <span class="n">get_layer</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_letter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index_from_letter</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">ops_all</span><span class="p">)</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">letter_from_index</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ops_all</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops_all</span><span class="p">)</span> <span class="ow">or</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error while generating Wyckoff_position: index out of range for specified group&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops_all</span><span class="p">[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">get_layer_symmetry</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">symmetry_m</span> <span class="o">=</span> <span class="n">get_layer_symmetry</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">generators</span> <span class="o">=</span> <span class="n">get_layer_generators</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">generators_m</span> <span class="o">=</span> <span class="n">get_layer_generators</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">76</span><span class="p">):</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">PBC</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="n">PBC</span>
            <span class="n">ops_all</span> <span class="o">=</span> <span class="n">get_rod</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_letter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index_from_letter</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">ops_all</span><span class="p">)</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wp</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">letter_from_index</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ops_all</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops_all</span><span class="p">)</span> <span class="ow">or</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error while generating Wyckoff_position: index out of range for specified group&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops_all</span><span class="p">[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">get_rod_symmetry</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">symmetry_m</span> <span class="o">=</span> <span class="n">get_rod_symmetry</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">generators</span> <span class="o">=</span> <span class="n">get_rod_generators</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
            <span class="n">wp</span><span class="o">.</span><span class="n">generators_m</span> <span class="o">=</span> <span class="n">get_rod_generators</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#TODO: implement Clusters</span>
            <span class="k">return</span> <span class="n">Wyckoff_position</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="s2">&quot;dim&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">wp</span></div>

<div class="viewcode-block" id="Wyckoff_position.wyckoff_from_generating_op"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Wyckoff_position.wyckoff_from_generating_op">[docs]</a>    <span class="k">def</span> <span class="nf">wyckoff_from_generating_op</span><span class="p">(</span><span class="n">gen_op</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a general position and generating operation (ex: &quot;x,0,0&quot;), returns a</span>
<span class="sd">        Wyckoff_position object.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            gen_op: a SymmOp into which the generating coordinate will be plugged</span>
<span class="sd">            gen_pos: a list of SymmOps representing the general position</span>

<span class="sd">        Returns:</span>
<span class="sd">            a list of SymmOps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">*</span><span class="n">gen_op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">gen_pos</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_ops</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="Wyckoff_position.symmetry_from_wyckoff"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Wyckoff_position.symmetry_from_wyckoff">[docs]</a>    <span class="k">def</span> <span class="nf">symmetry_from_wyckoff</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">):</span>
        <span class="n">symm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">wp</span><span class="p">:</span>
            <span class="n">symm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site_symm</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">symm</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiplicity</span>

<div class="viewcode-block" id="Wyckoff_position.get_site_symmetry"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Wyckoff_position.get_site_symmetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_site_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ss_string_from_ops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetry_m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Group"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Group">[docs]</a><span class="k">class</span> <span class="nc">Group</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing a set of Wyckoff positions for a symmetry group. See the documentation</span>
<span class="sd">    for details about settings.</span>

<span class="sd">    Args:</span>
<span class="sd">        group: the group symbol or international number</span>
<span class="sd">        dim: the periodic dimension of the group</span>
<span class="sd">    &quot;&quot;&quot;</span>
            

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#TODO: implement point group symbols</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Point group &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">+</span> <span class="s2">&quot; --&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Space &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Layer &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Rod &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;Error: invalid crystal dimension. Must be a number between 0 and 3.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;group # &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">+</span><span class="s2">&quot;)--&quot;</span>
            <span class="c1">#TODO: implement H-M symbol</span>
            <span class="c1">#s += symbol_from_number(self.number, dim=self.dim)</span>
            <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff_positions</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">)</span><span class="o">+</span><span class="n">wp</span><span class="o">.</span><span class="n">letter</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">site symm: &quot;</span> <span class="o">+</span> <span class="n">ss_string_from_ops</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">symmetry_m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
                <span class="c1">#for op in wp.ops:</span>
                <span class="c1">#    s += &quot;\n&quot; + op.as_xyz_string()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="c1">#TODO: get symbol from number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">group</span>
            <span class="n">number</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1">#TODO: add symbol interpretation</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Cannot currently interpret symbols for Rod, layer, and space groups.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span><span class="s2">&quot;Please use an integer.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">group</span>
                <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">pglist</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="n">symbol</span>
                    <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">group</span> <span class="o">=</span> <span class="n">pglist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Please input a symbol (str) or integer (int) for the group.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">231</span><span class="p">):</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_wyckoffs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="n">get_wyckoff_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">get_wyckoff_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=True)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">get_wyckoff_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">get_wyckoff_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;triclinic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;monoclinic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">74</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;orthorhombic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">142</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;tetragonal&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">194</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;hexagonal&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">230</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cubic&quot;</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">81</span><span class="p">):</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_layer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="n">get_layer_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False).&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">get_layer_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=True)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">get_layer_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">get_layer_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;triclinic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">18</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;monoclinic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">48</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;orthorhombic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;tetragonal&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">80</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;hexagonal&quot;</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">76</span><span class="p">):</span>
                <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_rod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="n">get_rod_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">get_rod_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                from get_wyckoff_symmetry (molecular=True)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">get_rod_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">get_rod_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;triclinic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;monoclinic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">22</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;orthorhombic&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">41</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;tetragonal&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">75</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;hexagonal&quot;</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#0-D clusters. Except for group &quot;I&quot; and &quot;Ih&quot;, z axis is the high-symmetry axis</span>
            <span class="c1">#https://en.wikipedia.org/wiki/Schoenflies_notation#Point_groups</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#Check if string is for crystallographic point group</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">pglist</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">pglist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1">#Get crystallographic point group</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">number</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">33</span><span class="p">):</span>
                    <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid symmetry group &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for dimension &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">get_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot;The Wyckoff positions for the crystal&#39;s spacegroup.&quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="n">get_point_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                    from get_wyckoff_symmetry (molecular=False)&quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">get_point_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot;A list of site symmetry operations for the Wyckoff positions, obtained</span>
<span class="sd">                    from get_wyckoff_symmetry (molecular=True)&quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">get_point_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=False)&quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">get_point_generators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot;A list of Wyckoff generators (molecular=True)&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cylindrical&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">27</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cylindrical&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;spherical&quot;</span>
            <span class="c1">#Get other point groups</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Remove whitespace</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">symbol</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isspace</span><span class="p">())</span>
                <span class="c1">#Find rotation order from symbol</span>
                <span class="n">num_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">symbol</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isalpha</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">num_str</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#infinite rotation order</span>
                <span class="k">elif</span> <span class="n">num_str</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#No rotation order</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_str</span><span class="p">)</span> <span class="c1">#rotation order</span>
                        <span class="mi">1</span> <span class="o">/</span> <span class="n">num</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid rotation order for point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">return</span>
                <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)]</span> <span class="c1"># List of generator SymmOps</span>
                <span class="n">generate</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1">#interpret symbol</span>
                <span class="k">if</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
                    <span class="c1">#Icosohedral</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;spherical&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="c1">#Add 2, 3, and 5-fold rotations</span>
                    <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;-x,-y,z&#39;</span><span class="p">))</span>
                    <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;z,x,y&#39;</span><span class="p">))</span>
                    <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">aa2matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>

                    <span class="c1">#Add Wyckoff generating operations</span>
                    <span class="n">op_c</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,0,0&#39;</span><span class="p">)</span>
                    <span class="n">op_b</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,x,x&#39;</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">op_a</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_c</span><span class="p">,</span> <span class="n">op_b</span><span class="p">,</span> <span class="n">op_a</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;Ih&quot;</span><span class="p">:</span>
                        <span class="c1">#Add horizontal mirror plane</span>
                        <span class="n">mirror</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,-z&#39;</span><span class="p">)</span> <span class="c1">#m x,y,0</span>
                        <span class="n">gen_pos</span> <span class="o">=</span> <span class="n">generate_full_symmops</span><span class="p">([</span><span class="n">R2</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span> <span class="n">mirror</span><span class="p">],</span> <span class="o">.</span><span class="mi">03</span><span class="p">)</span>
                        <span class="n">op_d</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,y,z&#39;</span><span class="p">)</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_d</span><span class="p">,</span> <span class="n">op_c</span><span class="p">,</span> <span class="n">op_b</span><span class="p">,</span> <span class="n">op_a</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                    <span class="c1">#n-fold rotation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cylindrical&quot;</span>
                    <span class="k">if</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span>
                        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Invalid point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1">#infinite-order rotation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;C*&quot;</span>
                        <span class="n">generate</span><span class="o">=</span><span class="kc">False</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Add rotation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">aa2matrix</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">num</span><span class="p">)</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]))</span>
                        <span class="n">op_c</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,-x,z&#39;</span><span class="p">)</span>
                        <span class="n">op_b</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,0,z&#39;</span><span class="p">)</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_z</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                        <span class="c1">#Add vertical mirror plane</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;-x,y,z&#39;</span><span class="p">))</span> <span class="c1">#m 0,y,z</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;v&quot;</span>
                        <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_c</span><span class="p">,</span> <span class="n">op_z</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_c</span><span class="p">,</span> <span class="n">op_b</span><span class="p">,</span> <span class="n">op_z</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span>
                        <span class="c1">#Add horizontal mirror plane</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,-z&#39;</span><span class="p">))</span> <span class="c1">#m x,y,0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;h&quot;</span>
                        <span class="n">op_xy</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,0&#39;</span><span class="p">)</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_xy</span><span class="p">,</span> <span class="n">op_z</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                    <span class="c1">#n-fold rotinversion, usually just Ci</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cylindrical&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;d&quot;</span> <span class="ow">in</span> <span class="n">symbol</span> <span class="ow">or</span> <span class="s2">&quot;h&quot;</span> <span class="ow">in</span> <span class="n">symbol</span> <span class="ow">or</span> <span class="s2">&quot;v&quot;</span> <span class="ow">in</span> <span class="n">symbol</span><span class="p">:</span>
                        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Invalid point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1">#infinite-order rotation</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;-x,-y,-z&#39;</span><span class="p">))</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,-z&#39;</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;C*i&quot;</span>
                        <span class="n">generate</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Add rotoinversion</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aa2matrix</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">num</span><span class="p">),</span> <span class="p">[[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;Ci&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;i&quot;</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_z</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span>
                    <span class="c1">#n-fold rotation and n 2-fold perpendicular rotations</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cylindrical&quot;</span>
                    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1">#infinite-order rotation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;D*&quot;</span>
                        <span class="n">generate</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Add rotation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                        <span class="c1">#Rotation angle</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">num</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">aa2matrix</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]))</span>
                        <span class="c1">#Different group orders have different multiplicities for &quot;D&quot; point groups</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1">#Add (x,0,0)</span>
                            <span class="n">gen_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_x</span><span class="p">)</span>
                            <span class="n">num2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span>
                            <span class="k">if</span> <span class="n">num2</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1">#Add num-fold symmetry axis</span>
                                <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="n">num2</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="c1">#Add num2-fold symmetry axis</span>
                                <span class="n">m</span> <span class="o">=</span> <span class="n">aa2matrix</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">angle</span><span class="p">)</span>
                                <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1">#Add num-fold symmetry axis</span>
                            <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span>
                            <span class="c1">#Add half-angle reflection operation</span>
                            <span class="n">m_ref</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="mi">0</span><span class="p">],[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">m_ref</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]))</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;d&quot;</span>
                            <span class="c1">#Add (x,0,z)</span>
                            <span class="n">gen_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,0,z&#39;</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1">#Add symmetry element + z</span>
                                <span class="n">m0</span> <span class="o">=</span> <span class="n">symmetry_element_from_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">affine_matrix</span>
                                <span class="n">m0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">new_op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>
                                <span class="n">gen_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_op</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span>
                            <span class="c1">#Add horizontal mirror plane</span>
                            <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,-z&#39;</span><span class="p">))</span> <span class="c1">#m x,y,0</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;h&quot;</span>
                            <span class="n">gen_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,0&#39;</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1">#Add (x,0,z)</span>
                                <span class="n">gen_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,0,z&#39;</span><span class="p">))</span>
                            <span class="c1">#Add symmetry axis + z</span>
                            <span class="n">m0</span> <span class="o">=</span> <span class="n">symmetry_element_from_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">affine_matrix</span>
                            <span class="n">m0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">new_op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>
                            <span class="n">gen_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_op</span><span class="p">)</span>
                        <span class="c1">#Add generator op for axis, as well as z-axis and origin</span>
                        <span class="n">gen_ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op_z</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;D*&quot;</span> <span class="ow">or</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;v&quot;</span> <span class="ow">or</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
                        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">return</span>
                <span class="k">elif</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="c1">#2n-fold rotation-reflection axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span> <span class="o">=</span> <span class="s2">&quot;cylindrical&quot;</span>
                    <span class="c1">#Equivalent to Cnh for odd n</span>
                    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;v&quot;</span> <span class="ow">or</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span> <span class="ow">or</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;h&quot;</span> <span class="ow">or</span> <span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;d&quot;</span><span class="p">:</span>
                        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: invalid point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aa2matrix</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">num</span><span class="p">),</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
                    <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">op_xy</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,0&#39;</span><span class="p">)</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_xy</span><span class="p">,</span> <span class="n">op_z</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">gen_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">Identity</span><span class="p">,</span> <span class="n">op_z</span><span class="p">,</span> <span class="n">op_o</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Invalid point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="c1">#Generate full set of SymmOps</span>
                <span class="k">if</span> <span class="n">generate</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">gen_pos</span> <span class="o">=</span> <span class="n">generate_full_symmops</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;*&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">:</span>
                    <span class="c1">#Calculate Wyckoff positions</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">gen_ops</span><span class="p">:</span>
                        <span class="n">wp</span> <span class="o">=</span> <span class="n">Wyckoff_position</span><span class="o">.</span><span class="n">wyckoff_from_generating_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op</span><span class="p">:</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                            <span class="n">op2</span> <span class="o">=</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">wp</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">op2</span>
                            <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                    <span class="c1">#Calculate site symmetry and generators</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wyckoff_position</span><span class="o">.</span><span class="n">symmetry_from_wyckoff</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">gen_pos</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">:</span>
                    <span class="c1">#infinite rotational groups</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;C*&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,z&#39;</span><span class="p">)]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)]]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;C*h&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">op_z</span><span class="p">,</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,-z&#39;</span><span class="p">)],[</span><span class="n">op_o</span><span class="p">]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)]],[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,-z&#39;</span><span class="p">)]]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;C*v&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,z&#39;</span><span class="p">)]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)]]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;D*h&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">op_z</span><span class="p">,</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,-z&#39;</span><span class="p">)],[</span><span class="n">op_o</span><span class="p">]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)]],[[</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">from_xyz_string</span><span class="p">(</span><span class="s1">&#39;0,0,-z&#39;</span><span class="p">)]]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">printx</span><span class="p">(</span><span class="s2">&quot;Error: Invalid point group symbol.&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="c1">#TODO: Add self.symbol to dictionary</span>
        <span class="n">wpdicts</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;letter&quot;</span><span class="p">:</span> <span class="n">letter_from_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">),</span> <span class="s2">&quot;ops&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="s2">&quot;multiplicity&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;symmetry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;symmetry_m&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="s2">&quot;generators&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;generators_m&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoff_generators_m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="s2">&quot;PBC&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">,</span> <span class="s2">&quot;dim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="s2">&quot;symbol&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wyckoff_position</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">wpdict</span><span class="p">)</span> <span class="k">for</span> <span class="n">wpdict</span> <span class="ow">in</span> <span class="n">wpdicts</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;A list of Wyckoff_position objects, sorted by descending multiplicity&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="n">organized_wyckoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A 2D list of Wyckoff_position objects, grouped and sorted by</span>
<span class="sd">        multiplicity.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="Group.get_wyckoff_position"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Group.get_wyckoff_position">[docs]</a>    <span class="k">def</span> <span class="nf">get_wyckoff_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single Wyckoff_position object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            index: the index of the Wyckoff position within the group</span>
<span class="sd">                The largest position is always 0</span>

<span class="sd">        Returns: a Wyckoff_position object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1">#Extract letter from number-letter combinations (&quot;4d&quot;-&gt;&quot;d&quot;)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
                    <span class="n">letter</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="k">break</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index_from_letter</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff_positions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Group.get_wyckoff_symmetry"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Group.get_wyckoff_symmetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_wyckoff_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the site symmetry symbol for the Wyckoff position</span>

<span class="sd">        Args:</span>
<span class="sd">            index: the index of the Wyckoff position within the group</span>
<span class="sd">                The largest position is always 0</span>
<span class="sd">            molecular: whether to use the Euclidean operations or not (for hexagonal groups)</span>

<span class="sd">        Returns: a Hermann-Mauguin style string for the site symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1">#Extract letter from number-letter combinations (&quot;4d&quot;-&gt;&quot;d&quot;)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
                    <span class="n">letter</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="k">break</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index_from_letter</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_symm</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">molecular</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_symm_m</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ss_string_from_ops</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Group.get_wyckoff_symmetry_m"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Group.get_wyckoff_symmetry_m">[docs]</a>    <span class="k">def</span> <span class="nf">get_wyckoff_symmetry_m</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the site symmetry symbol for the Wyckoff position (with molecular=True)</span>

<span class="sd">        Args:</span>
<span class="sd">            index: the index of the Wyckoff position within the group</span>
<span class="sd">                The largest position is always 0</span>

<span class="sd">        Returns: a Hermann-Mauguin style string for the site symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_wyckoff_symmetry</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">molecular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff_positions</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_wyckoff_position</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiplicity</span>

<div class="viewcode-block" id="Group.print_all"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Group.print_all">[docs]</a>    <span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints useful information about the Group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string_long</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Space &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Layer &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Rod &quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-- Point group &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">+</span> <span class="s2">&quot; --&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;group # &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; --&quot;</span>
            <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff_positions</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">)</span><span class="o">+</span><span class="n">wp</span><span class="o">.</span><span class="n">letter</span><span class="o">+</span><span class="s2">&quot; site symm: &quot;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">ss_string_from_ops</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">symmetry_m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">wp</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span> <span class="o">+</span> <span class="n">op</span><span class="o">.</span><span class="n">as_xyz_string</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string_long</span> <span class="o">=</span> <span class="n">s</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string_long</span><span class="p">)</span></div>

<div class="viewcode-block" id="Group.gen_pos"><a class="viewcode-back" href="../../pyxtal.symmetry.html#pyxtal.symmetry.Group.gen_pos">[docs]</a>    <span class="k">def</span> <span class="nf">gen_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the general Wyckoff position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyXtal 0.1dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Qiang Zhu, Scott Fredericks.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>