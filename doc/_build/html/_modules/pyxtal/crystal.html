
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyxtal.crystal &#8212; PyXtal 0.1dev documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyXtal 0.1dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyxtal.crystal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for generation of random atomic crystals with symmetry constraints. A</span>
<span class="sd">pymatgen- or spglib-type structure object is created, which can be saved to a</span>
<span class="sd">.cif file. Options (preceded by two dashes) are provided for command-line usage</span>
<span class="sd">of the module:  </span>

<span class="sd">    spacegroup (-s): the international spacegroup number (between 1 and 230)</span>
<span class="sd">        to be generated. In the case of a 2D crystal (using option &#39;-d 2&#39;),</span>
<span class="sd">        this will instead be the layer group number (between 1 and 80).</span>
<span class="sd">        Defaults to 36.  </span>

<span class="sd">    element (-e): the chemical symbol of the atom(s) to use. For multiple</span>
<span class="sd">        molecule types, separate entries with commas. Ex: &quot;C&quot;, &quot;H, O, N&quot;.</span>
<span class="sd">        Defaults to &quot;Li&quot;  </span>

<span class="sd">    numIons (-n): the number of atoms in the PRIMITIVE unit cell</span>
<span class="sd">        (For P-type spacegroups, this is the same as the number of molecules in</span>
<span class="sd">        the conventional unit cell. For A, B, C, and I-centered spacegroups,</span>
<span class="sd">        this is half the number of the conventional cell. For F-centered unit</span>
<span class="sd">        cells, this is one fourth the number of the conventional cell.).</span>
<span class="sd">        For multiple atom types, separate entries with commas.</span>
<span class="sd">        Ex: &quot;8&quot;, &quot;1, 4, 12&quot;. Defaults to 16  </span>

<span class="sd">    factor (-f): the relative volume factor used to generate the unit cell.</span>
<span class="sd">        Larger values result in larger cells, with atoms spaced further apart.</span>
<span class="sd">        If generation fails after max attempts, consider increasing this value.</span>
<span class="sd">        Defaults to 1.0  </span>

<span class="sd">    verbosity (-v): the amount of information which should be printed for each</span>
<span class="sd">        generated structure. For 0, only prints the requested and generated</span>
<span class="sd">        spacegroups. For 1, also prints the contents of the generated pymatgen</span>
<span class="sd">        structure. Defaults to 0  </span>

<span class="sd">    attempts (-a): the number of structures to generate. Note: if any of the</span>
<span class="sd">        attempts fail, the number of generated structures will be less than this</span>
<span class="sd">        value. Structures will be output to separate cif files. Defaults to 1  </span>

<span class="sd">    outdir (-o): the file directory where cif files will be output to.</span>
<span class="sd">        Defaults to &quot;out&quot;  </span>

<span class="sd">    dimension (-d): 3 for 3D, or 2 for 2D, 1 for 1D. If 2D, generates a 2D</span>
<span class="sd">        crystal using a layer group number instead of a space group number. For</span>
<span class="sd">        1D, we use a Rod group number. Defaults to 3  </span>

<span class="sd">    thickness (-t): The thickness, in Angstroms, to use when generating a</span>
<span class="sd">        2D crystal. Note that this will not necessarily be one of the lattice</span>
<span class="sd">        vectors, but will represent the perpendicular distance along the non-</span>
<span class="sd">        periodic direction. For 1D crystals, we use this value</span>
<span class="sd">        as the cross-sectional area of the crystal. Defaults to None  </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">exists</span>

<span class="kn">from</span> <span class="nn">spglib</span> <span class="k">import</span> <span class="n">get_symmetry_dataset</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Molecule</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.cif</span> <span class="k">import</span> <span class="n">CifWriter</span>

<span class="kn">from</span> <span class="nn">optparse</span> <span class="k">import</span> <span class="n">OptionParser</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">uniform</span> <span class="k">as</span> <span class="n">rand_u</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">choice</span> <span class="k">as</span> <span class="n">choose</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">acos</span><span class="p">,</span> <span class="n">fabs</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">pyxtal.database.element</span> <span class="k">import</span> <span class="n">Element</span>
<span class="kn">import</span> <span class="nn">pyxtal.database.hall</span> <span class="k">as</span> <span class="nn">hall</span>
<span class="kn">from</span> <span class="nn">pyxtal.database.layergroup</span> <span class="k">import</span> <span class="n">Layergroup</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">OperationAnalyzer</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">angle</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">random_vector</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">are_equal</span>
<span class="kn">from</span> <span class="nn">pyxtal.operations</span> <span class="k">import</span> <span class="n">random_shear_matrix</span>
<span class="kn">from</span> <span class="nn">pyxtal.symmetry</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1">#some optional libs</span>
<span class="c1">#from vasp import read_vasp</span>
<span class="c1">#from pymatgen.symmetry.analyzer import SpacegroupAnalyzer</span>
<span class="c1">#from os.path import isfile</span>

<span class="c1">#Define variables</span>
<span class="c1">#------------------------------</span>
<span class="n">tol_m</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#seperation tolerance in Angstroms</span>
<span class="n">max1</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#Attempts for generating lattices</span>
<span class="n">max2</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#Attempts for a given lattice</span>
<span class="n">max3</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#Attempts for a given Wyckoff position</span>
<span class="n">minvec</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="c1">#minimum vector length</span>
<span class="c1">#Matrix for a Euclidean metric</span>
<span class="n">Euclidean_lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>


<span class="c1">#Define functions</span>
<span class="c1">#------------------------------</span>
<div class="viewcode-block" id="Tol_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix">[docs]</a><span class="k">class</span> <span class="nc">Tol_matrix</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for variable distance tolerance checking. Used within random_crystal and</span>
<span class="sd">    molecular_crystal to verify whether atoms are too close. Stores a matrix of atom-</span>
<span class="sd">    atom pair tolerances. Note that the matrix&#39;s indices correspond to atomic numbers,</span>
<span class="sd">    with the 0th entries being 0 (there is no atomic number 0).</span>

<span class="sd">    Args:</span>
<span class="sd">        prototype: a string representing the type of radii to use</span>
<span class="sd">            (&quot;atomic&quot;, &quot;molecular&quot;, or &quot;metallic&quot;)</span>
<span class="sd">        factor: a float to scale the distances by. A smaller value means a smaller</span>
<span class="sd">            tolerance for distance checking</span>
<span class="sd">        tuples: a list or tuple of tuples, which define custom tolerance values. Each tuple</span>
<span class="sd">            should be of the form (specie1, specie2, value), where value is the tolerance</span>
<span class="sd">            in Angstroms, and specie1 and specie2 can be strings, integers, Element objects,</span>
<span class="sd">            or pymatgen Specie objects. Custom values may also be set using set_tol</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tuples</span><span class="p">,</span> <span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">prototype</span>
        <span class="k">if</span> <span class="n">prototype</span> <span class="o">==</span> <span class="s2">&quot;atomic&quot;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="n">attrindex</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_type</span> <span class="o">=</span> <span class="s2">&quot;covalent&quot;</span>
        <span class="k">elif</span> <span class="n">prototype</span> <span class="o">==</span> <span class="s2">&quot;molecular&quot;</span><span class="p">:</span>
            <span class="n">attrindex</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_type</span> <span class="o">=</span> <span class="s2">&quot;covalent&quot;</span>
            <span class="n">f</span> <span class="o">*=</span> <span class="mf">1.2</span>
        <span class="k">elif</span> <span class="n">prototype</span> <span class="o">==</span> <span class="s2">&quot;metallic&quot;</span><span class="p">:</span>
            <span class="n">attrindex</span> <span class="o">=</span> <span class="mi">7</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_type</span> <span class="o">=</span> <span class="s2">&quot;metallic&quot;</span>
            <span class="n">f</span> <span class="o">*=</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_type</span> <span class="o">=</span> <span class="s2">&quot;N/A&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Element</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">elements_list</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tup1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">elements_list</span><span class="p">):</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tup2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">elements_list</span><span class="p">):</span>
                <span class="c1">#Get the appropriate atomic radii</span>
                <span class="k">if</span> <span class="n">tup1</span><span class="p">[</span><span class="n">attrindex</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tup1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">val1</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Use the covalent radius</span>
                        <span class="n">val1</span> <span class="o">=</span> <span class="n">tup1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val1</span> <span class="o">=</span> <span class="n">tup1</span><span class="p">[</span><span class="n">attrindex</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tup2</span><span class="p">[</span><span class="n">attrindex</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tup2</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">val2</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Use the covalent radius</span>
                        <span class="n">val2</span> <span class="o">=</span> <span class="n">tup1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val2</span> <span class="o">=</span> <span class="n">tup2</span><span class="p">[</span><span class="n">attrindex</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">val1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">val2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#If no radius is found for either atom, set tolerance to None</span>
                    <span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A symmetric numpy matrix storing the tolerance between specie pairs.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;A list of tuples storing which species pair tolerances have custom values.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">tuples</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_tol</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not set custom tolerance value(s).&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    All custom entries should be entered using the following form:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    (specie1, specie2, value), where value is the tolerance in Angstroms.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">radius_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tol</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="Tol_matrix.get_tol"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.get_tol">[docs]</a>    <span class="k">def</span> <span class="nf">get_tol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specie1</span><span class="p">,</span> <span class="n">specie2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tolerance between two species.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            specie1, specie2: the atomic number (int or float), name (str), symbol (str),</span>
<span class="sd">                an Element object, or a pymatgen Specie object</span>

<span class="sd">        Returns:</span>
<span class="sd">            the tolerance between the provided pair of atomic species</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span> <span class="o">==</span> <span class="s2">&quot;single_value&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">Element</span><span class="o">.</span><span class="n">number_from_specie</span><span class="p">(</span><span class="n">specie1</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="n">Element</span><span class="o">.</span><span class="n">number_from_specie</span><span class="p">(</span><span class="n">specie2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index1</span><span class="p">][</span><span class="n">index2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Tol_matrix.set_tol"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.set_tol">[docs]</a>    <span class="k">def</span> <span class="nf">set_tol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specie1</span><span class="p">,</span> <span class="n">specie2</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tolerance between two species.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            specie1, specie2: the atomic number (int or float), name (str), symbol (str),</span>
<span class="sd">                an Element object, or a pymatgen Specie object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">Element</span><span class="o">.</span><span class="n">number_from_specie</span><span class="p">(</span><span class="n">specie1</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="n">Element</span><span class="o">.</span><span class="n">number_from_specie</span><span class="p">(</span><span class="n">specie2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">index2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index1</span><span class="p">][</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index1</span> <span class="o">!=</span> <span class="n">index2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index2</span><span class="p">][</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_values</span> <span class="ow">and</span> <span class="p">(</span><span class="n">index2</span><span class="p">,</span> <span class="n">index1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_values</span><span class="p">:</span>
            <span class="n">larger</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span>
            <span class="n">smaller</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">smaller</span><span class="p">,</span> <span class="n">larger</span><span class="p">))</span></div>

<div class="viewcode-block" id="Tol_matrix.from_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.from_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">begin_with</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a tolerance matrix, returns a Tol_matrix object. Matrix indices correspond to</span>
<span class="sd">        the atomic number (with 0 pointing to Hydrogen by default). For atoms with atomic</span>
<span class="sd">        numbers not included in the matrix, the default value (specified by prototype) will be</span>
<span class="sd">        used, up to element 96. Note that if the matrix is asymmetric, only the value below the</span>
<span class="sd">        diagonal will be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            matrix: a 2D matrix or list of tolerances between atomic species pairs</span>
<span class="sd">            prototype: a string representing the type of radii to use</span>
<span class="sd">                (&quot;atomic&quot;, &quot;molecular&quot;)</span>
<span class="sd">            factor: a float to scale the distances by. A smaller value means a smaller</span>
<span class="sd">                tolerance for distance checking</span>
<span class="sd">            begin_with: the index which points to Hydrogen within the matrix. Default 0</span>

<span class="sd">        Returns:</span>
<span class="sd">            a Tol_matrix object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">tups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">tups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">begin_with</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">begin_with</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="n">prototype</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span> <span class="o">*</span><span class="n">tups</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tm</span></div>

<div class="viewcode-block" id="Tol_matrix.from_radii"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.from_radii">[docs]</a>    <span class="k">def</span> <span class="nf">from_radii</span><span class="p">(</span><span class="n">radius_list</span><span class="p">,</span> <span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">begin_with</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of atomic radii, returns a Tol_matrix object. For atom-atom pairs, uses</span>
<span class="sd">        the average radii of the two species as the tolerance value. For atoms with atomic</span>
<span class="sd">        numbers not in the radius list, the default value (specified by prototype) will be</span>
<span class="sd">        used, up to element 96.</span>

<span class="sd">        Args:</span>
<span class="sd">            radius_list: a list of atomic radii (in Angstroms), beginning with Hydrogen</span>
<span class="sd">            prototype: a string representing the type of radii to use</span>
<span class="sd">                (&quot;atomic&quot;, &quot;molecular&quot;)</span>
<span class="sd">            factor: a float to scale the distances by. A smaller value means a smaller</span>
<span class="sd">                tolerance for distance checking</span>
<span class="sd">            begin_with: the index which points to Hydrogen within the list. Default 0</span>

<span class="sd">        Returns:</span>
<span class="sd">            a Tol_matrix object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">radius_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">r2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">radius_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">tups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">begin_with</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">begin_with</span><span class="p">,</span> <span class="n">f</span><span class="o">*</span><span class="p">(</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">))</span> <span class="p">)</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="n">prototype</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span> <span class="o">*</span><span class="n">tups</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tm</span></div>

<div class="viewcode-block" id="Tol_matrix.from_single_value"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.from_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">from_single_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Tol_matrix which only has a single tolerance value. Using get_tol will</span>
<span class="sd">        always return the same value.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: the tolerance value to use</span>

<span class="sd">        Returns:</span>
<span class="sd">            as Tol_matrix object whose methods are overridden to use a single tolerance value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">Tol_matrix</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="s2">&quot;single value&quot;</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">value</span><span class="p">]])</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">custom_values</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">radius_type</span> <span class="o">=</span> <span class="s2">&quot;N/A&quot;</span>
        <span class="k">return</span> <span class="n">tm</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">Element</span><span class="o">.</span><span class="n">number_from_specie</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<div class="viewcode-block" id="Tol_matrix.print_all"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.print_all">[docs]</a>    <span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--Tol_matrix class object--&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Prototype: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prototype</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Atomic radius type: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius_type</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Radius scaling factor: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span> <span class="o">==</span> <span class="s2">&quot;single value&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Custom tolerance value: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_values</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Custom tolerance values: None&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Custom tolerance values:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_values</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">short_name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">short_name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tol</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span></div>

<div class="viewcode-block" id="Tol_matrix.to_file"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a file with the given filename and file type to store the structure.</span>
<span class="sd">        By default, creates cif files for crystals and xyz files for clusters.</span>
<span class="sd">        By default, the filename is based on the stoichiometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            fmt: the file type (&#39;cif&#39;, &#39;xyz&#39;, etc.)</span>
<span class="sd">            filename: the file path</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nothing. Creates a file at the specified path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">given</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">given</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;custom_tol_matrix&quot;</span>
        <span class="c1">#Check if filename already exists</span>
        <span class="c1">#If it does, add a new number to end of filename</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">outdir</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">outdir</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;Could not create file: too many files already created.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outdir</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">return</span> <span class="s2">&quot;Output file to &quot;</span> <span class="o">+</span> <span class="n">outdir</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Error: Could not save Tol_matrix to file.&quot;</span></div>

<div class="viewcode-block" id="Tol_matrix.from_file"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Tol_matrix.from_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tol_matrix</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tm</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: invalid file for Tol_matrix.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not load Tol_matrix from file.&quot;</span><span class="p">)</span>
            <span class="k">return</span></div></div>

<div class="viewcode-block" id="gaussian"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.gaussian">[docs]</a><span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a random number from a Gaussian probability distribution centered</span>
<span class="sd">    between min and max. sigma is the number of standard deviations that min</span>
<span class="sd">    and max are away from the center. Thus, sigma is also the largest possible</span>
<span class="sd">    number of standard deviations corresponding to the returned value. sigma=2</span>
<span class="sd">    corresponds to a 95.45% probability of choosing a number between min and</span>
<span class="sd">    max.</span>

<span class="sd">    Args:</span>
<span class="sd">        min: the minimum acceptable value</span>
<span class="sd">        max: the maximum acceptable value</span>
<span class="sd">        sigma: the number of standard deviations between the center and min or max</span>

<span class="sd">    Returns:</span>
<span class="sd">        a value chosen randomly between min and max</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="o">+</span><span class="nb">min</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="nb">max</span><span class="o">-</span><span class="nb">min</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">delta</span><span class="o">/</span><span class="n">sigma</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="nb">min</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="get_tol"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_tol">[docs]</a><span class="k">def</span> <span class="nf">get_tol</span><span class="p">(</span><span class="n">specie</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an atomic specie name, return the covalent radius.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        specie: a string for the atomic symbol</span>

<span class="sd">    Returns:</span>
<span class="sd">        the covalent radius in Angstroms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span></div>

<span class="n">tols_from_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">get_tol</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Given a list of atomic species names, returns a list of</span>
<span class="sd">covalent radii</span>

<span class="sd">Args:</span>
<span class="sd">    species: a list of strings for atomic species names or symbols</span>

<span class="sd">Returns:</span>
<span class="sd">    A 1D numpy array of distances in Angstroms</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="check_distance"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.check_distance">[docs]</a><span class="k">def</span> <span class="nf">check_distance</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">,</span> <span class="n">species1</span><span class="p">,</span> <span class="n">species2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">tm</span><span class="o">=</span><span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">),</span> <span class="n">d_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the distances between two set of atoms. Distances between coordinates</span>
<span class="sd">    within the first set are not checked, and distances between coordinates within</span>
<span class="sd">    the second set are not checked. Only distances between points from different</span>
<span class="sd">    sets are checked.</span>

<span class="sd">    Args:</span>
<span class="sd">        coord1: a list of fractional coordinates e.g. [[.1,.6,.4]</span>
<span class="sd">            [.3,.8,.2]]</span>
<span class="sd">        coord2: a list of new fractional coordinates e.g. [[.7,.8,.9],</span>
<span class="sd">            [.4,.5,.6]]</span>
<span class="sd">        species1: a list of atomic species or numbers for coord1</span>
<span class="sd">        species2: a list of atomic species or numbers for coord2</span>
<span class="sd">        lattice: matrix describing the unit cell vectors</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">        tm: a Tol_matrix object, or a string representing the type of Tol_matrix</span>
<span class="sd">            to use</span>
<span class="sd">        d_factor: the tolerance is multiplied by this amount. Larger values</span>
<span class="sd">            mean atoms must be farther apart</span>

<span class="sd">    Returns:</span>
<span class="sd">        a bool for whether or not the atoms are sufficiently far enough apart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Check that there are points to compare</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1">#Create tolerance matrix from subset of tm</span>
    <span class="n">tols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">species1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">species2</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">specie1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">species1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">specie2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">species2</span><span class="p">):</span>
            <span class="n">tols</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">get_tol</span><span class="p">(</span><span class="n">specie1</span><span class="p">,</span> <span class="n">specie2</span><span class="p">)</span>

    <span class="c1">#Calculate the distance between each i, j pair</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">distance_matrix</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>

    <span class="c1">#Check if the distance is ever less than the tolerance</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">tols</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="check_images"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.check_images">[docs]</a><span class="k">def</span> <span class="nf">check_images</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">tm</span><span class="o">=</span><span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">),</span> <span class="n">d_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of (unfiltered) fractional coordinates, checks if the periodic images are too close.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">new_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_species</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">+</span><span class="n">v</span><span class="p">:</span>
            <span class="n">new_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">new_species</span> <span class="o">+=</span> <span class="n">species</span>
    <span class="k">return</span> <span class="n">check_distance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_coords</span><span class="p">),</span> <span class="n">species</span><span class="p">,</span> <span class="n">new_species</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">tm</span><span class="o">=</span><span class="n">tm</span><span class="p">,</span> <span class="n">d_factor</span><span class="o">=</span><span class="n">d_factor</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_center"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.get_center">[docs]</a><span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the geometric centers of the clusters under periodic boundary</span>
<span class="sd">    conditions.</span>

<span class="sd">    Args:</span>
<span class="sd">        xyzs: a list of fractional coordinates</span>
<span class="sd">        lattice: a matrix describing the unit cell</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        x,y,z coordinates for the center of the input coordinate list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix0</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">xyzs</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)</span>
    <span class="n">matrix_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)):</span>
        <span class="n">dist_min</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">atom1</span><span class="p">):</span>
            <span class="c1">#shift atom1 to position close to atom2</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix0</span> <span class="o">+</span> <span class="p">(</span><span class="n">xyzs</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyzs</span><span class="p">[</span><span class="n">atom2</span><span class="p">])</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist_min</span><span class="p">:</span>
                <span class="n">dist_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
                <span class="n">matrix_min</span> <span class="o">=</span> <span class="n">matrix0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)]</span>
        <span class="n">xyzs</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">matrix_min</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">xyzs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">center</span></div>

<div class="viewcode-block" id="para2matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.para2matrix">[docs]</a><span class="k">def</span> <span class="nf">para2matrix</span><span class="p">(</span><span class="n">cell_para</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of lattic parameters, generates a matrix representing the</span>
<span class="sd">    lattice vectors</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_para: a 1x6 list of lattice parameters [a, b, c, alpha, beta,</span>
<span class="sd">            gamma]. a, b, and c are the length of the lattice vectos, and</span>
<span class="sd">            alpha, beta, and gamma are the angles between these vectors. Can</span>
<span class="sd">            be generated by matrix2para</span>
<span class="sd">        radians: if True, lattice parameters should be in radians. If False,</span>
<span class="sd">            lattice angles should be in degrees</span>
<span class="sd">        format: a string (&#39;lower&#39;, &#39;symmetric&#39;, or &#39;upper&#39;) for the type of</span>
<span class="sd">            matrix to be output</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the unit cell. By default (format=&#39;lower&#39;),</span>
<span class="sd">        the a vector is aligined along the x-axis, and the b vector is in the</span>
<span class="sd">        y-z plane</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">cell_para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">radians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">rad</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>
        <span class="n">alpha</span> <span class="o">*=</span> <span class="n">rad</span>
        <span class="n">beta</span> <span class="o">*=</span> <span class="n">rad</span>
        <span class="n">gamma</span> <span class="o">*=</span> <span class="n">rad</span>
    <span class="n">cos_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">cos_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="n">cos_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">sin_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
        <span class="c1">#Generate a lower-diagonal matrix</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">cos_beta</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">cos_alpha</span> <span class="o">-</span> <span class="p">(</span><span class="n">cos_beta</span> <span class="o">*</span> <span class="n">cos_gamma</span><span class="p">)))</span> <span class="o">/</span> <span class="n">sin_gamma</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cos_gamma</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin_gamma</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span>
        <span class="c1">#TODO: allow generation of symmetric matrices</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
        <span class="c1">#Generate an upper-diagonal matrix</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos_beta</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cos_gamma</span> <span class="o">-</span> <span class="p">(</span><span class="n">cos_beta</span> <span class="o">*</span> <span class="n">cos_alpha</span><span class="p">)))</span> <span class="o">/</span> <span class="n">sin_alpha</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cos_alpha</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin_alpha</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="Add_vacuum"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Add_vacuum">[docs]</a><span class="k">def</span> <span class="nf">Add_vacuum</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds space above and below a 2D or 1D crystal. This allows for treating the</span>
<span class="sd">    structure as a 3D crystal during energy optimization</span>

<span class="sd">    Args:</span>
<span class="sd">        lattice: the lattice matrix of the crystal</span>
<span class="sd">        coor: the relative coordinates of the crystal</span>
<span class="sd">        vacuum: the amount of space, in Angstroms, to add above and below</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>

<span class="sd">    Returns:</span>
<span class="sd">        lattice, coor: The transformed lattice and coordinates after the</span>
<span class="sd">            vacuum space is added</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">absolute_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PBC</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">lattice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">lattice</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">*</span> <span class="n">vacuum</span>
    <span class="n">new_coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lattice</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">new_coor</span></div>

<div class="viewcode-block" id="Permutation"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Permutation">[docs]</a><span class="k">def</span> <span class="nf">Permutation</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">PB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permutes a list of coordinates. Not currently implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">para</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
    <span class="n">para1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">para</span><span class="p">)</span>
    <span class="n">coor1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">para1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">para</span><span class="p">[</span><span class="n">PB</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">para1</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">para</span><span class="p">[</span><span class="n">PB</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">coor1</span><span class="p">[:,</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">coor</span><span class="p">[:,</span><span class="n">PB</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">para2matrix</span><span class="p">(</span><span class="n">para1</span><span class="p">),</span> <span class="n">coor1</span></div>

<div class="viewcode-block" id="matrix2para"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.matrix2para">[docs]</a><span class="k">def</span> <span class="nf">matrix2para</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a 3x3 matrix representing a unit cell, outputs a list of lattice</span>
<span class="sd">    parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: a 3x3 array or list, where the first, second, and third rows</span>
<span class="sd">            represent the a, b, and c vectors respectively</span>
<span class="sd">        radians: if True, outputs angles in radians. If False, outputs in</span>
<span class="sd">            degrees</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 1x6 list of lattice parameters [a, b, c, alpha, beta, gamma]. a, b,</span>
<span class="sd">        and c are the length of the lattice vectos, and alpha, beta, and gamma</span>
<span class="sd">        are the angles between these vectors (in radians by default)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell_para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="c1">#a</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1">#b</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#c</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#alpha</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#beta</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#gamma</span>
    <span class="n">cell_para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
        <span class="c1">#convert radians to degrees</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="mf">180.</span><span class="o">/</span><span class="n">pi</span>
        <span class="n">cell_para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">deg</span>
        <span class="n">cell_para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*=</span> <span class="n">deg</span>
        <span class="n">cell_para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*=</span> <span class="n">deg</span>
    <span class="k">return</span> <span class="n">cell_para</span></div>

<span class="c1">#TODO: replace sg with number, dim</span>
<div class="viewcode-block" id="cellsize"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.cellsize">[docs]</a><span class="k">def</span> <span class="nf">cellsize</span><span class="p">(</span><span class="n">sg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of duplicate atoms in the conventional lattice (in</span>
<span class="sd">    contrast to the primitive cell). Based on the type of cell centering (P,</span>
<span class="sd">    A, C, I, R, or F)</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>

<span class="sd">    Returns:</span>
<span class="sd">        a number between 1 and 4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#For 1D crystals</span>
    <span class="k">if</span> <span class="n">sg</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="c1">#Get the H-M symbol</span>
    <span class="n">symbol</span> <span class="o">=</span> <span class="n">sg_symbol_from_int_number</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
    <span class="n">letter</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
    	<span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">]:</span>
    	<span class="k">return</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]:</span>
    	<span class="k">return</span> <span class="mi">3</span>
    <span class="k">elif</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]:</span>
    	<span class="k">return</span> <span class="mi">4</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;Error: Could not determine lattice type&quot;</span></div>

<div class="viewcode-block" id="find_short_dist"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.find_short_dist">[docs]</a><span class="k">def</span> <span class="nf">find_short_dist</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of fractional coordinates, finds pairs which are closer</span>
<span class="sd">    together than tol, and builds the connectivity map</span>

<span class="sd">    Args:</span>
<span class="sd">        coor: a list of fractional 3-dimensional coordinates</span>
<span class="sd">        lattice: a matrix representing the crystal unit cell</span>
<span class="sd">        tol: the distance tolerance for pairing coordinates</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        pairs, graph: (pairs) is a list whose entries have the form [index1,</span>
<span class="sd">        index2, distance], where index1 and index2 correspond to the indices</span>
<span class="sd">        of a pair of points within the supplied list (coor). distance is the</span>
<span class="sd">        distance between the two points. (graph) is a connectivity map in the</span>
<span class="sd">        form of a list. Its first index represents a point within coor, and</span>
<span class="sd">        the second indices represent which point(s) it is connected to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pairs</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">graph</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)):</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">distance_matrix</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
    <span class="n">ijs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span><span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ijs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ijs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span>

    <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pairs</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-3</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">pairs</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d_min</span><span class="p">]</span>
        <span class="c1">#Avoid Futurewarning</span>
        <span class="c1">#pairs1 = deepcopy(pairs)</span>
        <span class="c1">#pairs = pairs1[sequence]</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sequence</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">pair0</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pair1</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">pair0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair1</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">pair1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pairs</span><span class="p">,</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="connected_components"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.connected_components">[docs]</a><span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an undirected graph (a 2d array of indices), return a set of</span>
<span class="sd">    connected components, each connected component being an (arbitrarily</span>
<span class="sd">    ordered) array of indices which are connected either directly or</span>
<span class="sd">    indirectly.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph: a list reprenting the connections between points. The first index</span>
<span class="sd">            represents a point, and the 2nd indices represent the points to</span>
<span class="sd">            which the first point is connected. Can be generated by</span>
<span class="sd">            find_short_dist</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of connected components. The first index denotes a separate</span>
<span class="sd">        connected component. The second indices denote the points within the</span>
<span class="sd">        connected component which are connected to each other</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">add_neighbors</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all elements which are connected to el. Return an array which</span>
<span class="sd">        includes these elements and el itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#seen stores already-visited indices</span>
        <span class="k">if</span> <span class="n">seen</span> <span class="o">==</span> <span class="p">[]:</span> <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
        <span class="c1">#iterate through the neighbors (x) of el</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">el</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1">#Recursively find neighbors of x</span>
                <span class="n">add_neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">seen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seen</span>

    <span class="c1">#Create a list of indices to iterate through</span>
    <span class="n">unseen</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)))</span>
    <span class="n">sets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">unseen</span> <span class="o">!=</span> <span class="p">[]):</span>
        <span class="c1">#x is the index we are finding the connected component of</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">unseen</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">sets</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#Add neighbors of x to the current connected component</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">add_neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="c1">#Remove indices which have already been found</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">unseen</span><span class="p">:</span> <span class="n">unseen</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">sets</span></div>

<div class="viewcode-block" id="merge_coordinate"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.merge_coordinate">[docs]</a><span class="k">def</span> <span class="nf">merge_coordinate</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of fractional coordinates, merges them within a given</span>
<span class="sd">    tolerance, and checks if the merged coordinates satisfy a Wyckoff</span>
<span class="sd">    position. Used for merging general Wyckoff positions into special Wyckoff</span>
<span class="sd">    positions within the random_crystal (and its derivative) classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        coor: a list of fractional coordinates</span>
<span class="sd">        lattice: a 3x3 matrix representing the unit cell</span>
<span class="sd">        group: a pyxtal.symmetry.Group object</span>
<span class="sd">        tol: the cutoff distance for merging coordinates</span>

<span class="sd">    Returns:</span>
<span class="sd">        coor, index, point: (coor) is the new list of fractional coordinates after</span>
<span class="sd">        merging. index is a single index for the Wyckoff position within</span>
<span class="sd">        the sg. If no matching WP is found, returns False. point is a 3-vector;</span>
<span class="sd">        when plugged into the Wyckoff position, it will generate all the other</span>
<span class="sd">        points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">wyckoffs</span>
    <span class="n">PBC</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">PBC</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">pairs</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">find_short_dist</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">components</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                    <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_center</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">))</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">check_wyckoff_position</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">coor</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coor</span> <span class="o">=</span> <span class="n">merged</span>

            <span class="k">else</span><span class="p">:</span><span class="c1">#no way to merge</span>
                <span class="k">return</span> <span class="n">coor</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">check_wyckoff_position</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coor</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">point</span></div>

<div class="viewcode-block" id="estimate_volume"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.estimate_volume">[docs]</a><span class="k">def</span> <span class="nf">estimate_volume</span><span class="p">(</span><span class="n">numIons</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates the volume of a unit cell based on the number and types of ions.</span>
<span class="sd">    Assumes each atom takes up a sphere with radius equal to its covalent bond</span>
<span class="sd">    radius.</span>

<span class="sd">    Args:</span>
<span class="sd">        numIons: a list of the number of ions for each specie</span>
<span class="sd">        species: a corresponding list for the specie of each type of ion. Each</span>
<span class="sd">            element in the list should be a string for the atomic symbol</span>
<span class="sd">        factor: an optional factor to multiply the result by. Larger values</span>
<span class="sd">            allow more space between atoms</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        a float value for the estimated volume</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">numIon</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">numIons</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rand_u</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">,</span> <span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">vdw_radius</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">+=</span> <span class="n">numIon</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">factor</span><span class="o">*</span><span class="n">volume</span></div>

<div class="viewcode-block" id="generate_lattice"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.generate_lattice">[docs]</a><span class="k">def</span> <span class="nf">generate_lattice</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">tol_m</span><span class="p">,</span> <span class="n">minangle</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">maxattempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a lattice (3x3 matrix) according to the space group symmetry and</span>
<span class="sd">    number of atoms. If the spacegroup has centering, we will transform to</span>
<span class="sd">    conventional cell setting. If the generated lattice does not meet the</span>
<span class="sd">    minimum angle and vector requirements, we try to generate a new one, up to</span>
<span class="sd">    maxattempts times.</span>

<span class="sd">    Args:</span>
<span class="sd">        sg: International number of the space group</span>
<span class="sd">        volume: volume of the conventional unit cell</span>
<span class="sd">        minvec: minimum allowed lattice vector length (among a, b, and c)</span>
<span class="sd">        minangle: minimum allowed lattice angle (among alpha, beta, and gamma)</span>
<span class="sd">        max_ratio: largest allowed ratio of two lattice vector lengths</span>
<span class="sd">        maxattempts: the maximum number of attempts for generating a lattice</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the lattice vectors of the unit cell. If</span>
<span class="sd">        generation fails, outputs a warning message and returns empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxangle</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-</span><span class="n">minangle</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxattempts</span><span class="p">):</span>
        <span class="c1">#Triclinic</span>
        <span class="c1">#if sg &lt;= 2:</span>
        <span class="k">if</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span>
            <span class="c1">#Derive lattice constants from a random matrix</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">random_shear_matrix</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)))</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">abc</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">x</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="c1">#Monoclinic</span>
        <span class="c1">#elif sg &lt;= 15:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span>  <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">abc</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">x</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="c1">#Orthorhombic</span>
        <span class="c1">#elif sg &lt;= 74:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;orthorhombic&quot;</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">abc</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">x</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="c1">#Tetragonal</span>
        <span class="c1">#elif sg &lt;= 142:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">#Trigonal/Rhombohedral/Hexagonal</span>
        <span class="c1">#elif sg &lt;= 194:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">#Cubic</span>
        <span class="c1">#else:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;cubic&quot;</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span>
        <span class="c1">#Check that lattice meets requirements</span>
        <span class="n">maxvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">minvec</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minvec</span> <span class="o">&lt;</span> <span class="n">maxvec</span><span class="p">:</span>
            <span class="c1">#Check minimum Euclidean distances</span>
            <span class="n">smallvec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)))</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&gt;</span><span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">maxvec</span>
            <span class="ow">and</span> <span class="n">smallvec</span> <span class="o">&lt;</span> <span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&gt;</span><span class="n">minangle</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&lt;</span><span class="n">maxangle</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span>
            <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>
    <span class="c1">#If maxattempts tries have been made without success</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate lattice after &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; attempts for volume &quot;</span><span class="p">,</span> <span class="n">volume</span><span class="p">)</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="generate_lattice_2D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.generate_lattice_2D">[docs]</a><span class="k">def</span> <span class="nf">generate_lattice_2D</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">tol_m</span><span class="p">,</span> <span class="n">minangle</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">maxattempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a lattice (3x3 matrix) according to the spacegroup symmetry and</span>
<span class="sd">    number of atoms. If the layer group has centering, we will use the</span>
<span class="sd">    conventional cell setting. If the generated lattice does not meet the</span>
<span class="sd">    minimum angle and vector requirements, we try to generate a new one, up to</span>
<span class="sd">    maxattempts times.</span>
<span class="sd">    Note: The monoclinic layer groups have different unique axes. Groups 3-7</span>
<span class="sd">        have unique axis c, while 8-18 have unique axis a. We use non-periodic</span>
<span class="sd">        axis c for all layer groups.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: International number of the space group</span>
<span class="sd">        volume: volume of the lattice</span>
<span class="sd">        thickness: 3rd-dimensional thickness of the unit cell. If set to None,</span>
<span class="sd">            a thickness is chosen automatically</span>
<span class="sd">        minvec: minimum allowed lattice vector length (among a, b, and c)</span>
<span class="sd">        minangle: minimum allowed lattice angle (among alpha, beta, and gamma)</span>
<span class="sd">        max_ratio: largest allowed ratio of two lattice vector lengths</span>
<span class="sd">        maxattempts: the maximum number of attempts for generating a lattice</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the lattice vectors of the unit cell. If</span>
<span class="sd">        generation fails, outputs a warning message and returns empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">unique_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;unique_axis&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
    <span class="c1">#Store the non-periodic axis</span>
    <span class="n">NPA</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="c1">#Set the unique axis for monoclinic cells</span>
    <span class="c1">#if num in range(3, 8): unique_axis = &quot;c&quot;</span>
    <span class="c1">#elif num in range(8, 19): unique_axis = &quot;a&quot;</span>
    <span class="n">maxangle</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-</span><span class="n">minangle</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxattempts</span><span class="p">):</span>
        <span class="n">abc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">thickness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">thickness1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thickness1</span> <span class="o">=</span> <span class="n">thickness</span>
        <span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thickness1</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span>  <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1">#Triclinic</span>
        <span class="c1">#if num &lt;= 2:</span>
        <span class="k">if</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">random_shear_matrix</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)))</span>
            <span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">x</span> <span class="c1">#scale thickness by outer product of vectors</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1">#Monoclinic</span>
        <span class="c1">#elif num &lt;= 18:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">unique_axis</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unique_axis</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unique_axis</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1">#Orthorhombic</span>
        <span class="c1">#elif num &lt;= 48:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;orthorhombic&quot;</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>

        <span class="c1">#Tetragonal</span>
        <span class="c1">#elif num &lt;= 64:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">thickness1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1">#Trigonal/Rhombohedral/Hexagonal</span>
        <span class="c1">#elif num &lt;= 80:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
            <span class="k">if</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">abc</span><span class="p">[</span><span class="n">NPA</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)(</span><span class="n">thickness1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">NPA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">maxvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">minvec</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minvec</span> <span class="o">&lt;</span> <span class="n">maxvec</span><span class="p">:</span>
            <span class="n">smallvec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)))</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&gt;</span><span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">maxvec</span>
            <span class="ow">and</span> <span class="n">smallvec</span> <span class="o">&lt;</span> <span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&gt;</span><span class="n">minangle</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&lt;</span><span class="n">maxangle</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span>
            <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">para</span>

    <span class="c1">#If maxattempts tries have been made without success</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate lattice after &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; attempts&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="generate_lattice_1D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.generate_lattice_1D">[docs]</a><span class="k">def</span> <span class="nf">generate_lattice_1D</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">tol_m</span><span class="p">,</span> <span class="n">minangle</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">maxattempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a lattice (3x3 matrix) according to the spacegroup symmetry and</span>
<span class="sd">    number of atoms. If the spacegroup has centering, we will transform to</span>
<span class="sd">    conventional cell setting. If the generated lattice does not meet the</span>
<span class="sd">    minimum angle and vector requirements, we try to generate a new one, up to</span>
<span class="sd">    maxattempts times.</span>
<span class="sd">    Note: The monoclinic Rod groups have different unique axes. Groups 3-7</span>
<span class="sd">        have unique axis a, while 8-12 have unique axis c. We use periodic</span>
<span class="sd">        axis c for all Rod groups.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: number of the Rod group</span>
<span class="sd">        volume: volume of the lattice</span>
<span class="sd">        area: cross-sectional area of the unit cell in Angstroms squared. If</span>
<span class="sd">            set to None, a value is chosen automatically</span>
<span class="sd">        minvec: minimum allowed lattice vector length (among a, b, and c)</span>
<span class="sd">        minangle: minimum allowed lattice angle (among alpha, beta, and gamma)</span>
<span class="sd">        max_ratio: largest allowed ratio of two lattice vector lengths</span>
<span class="sd">        maxattempts: the maximum number of attempts for generating a lattice</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the lattice vectors of the unit cell. If</span>
<span class="sd">        generation fails, outputs a warning message and returns empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">unique_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;unique_axis&#39;</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
    <span class="c1">#Store the periodic axis</span>
    <span class="n">PA</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="c1">#Set the unique axis for monoclinic cells</span>
    <span class="c1">#if num in range(3, 8): unique_axis = &quot;a&quot;</span>
    <span class="c1">#elif num in range(8, 13): unique_axis = &quot;c&quot;</span>
    <span class="n">maxangle</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-</span><span class="n">minangle</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxattempts</span><span class="p">):</span>
        <span class="n">abc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="n">thickness1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thickness1</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="n">area</span>
        <span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thickness1</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span>  <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1">#Triclinic</span>
        <span class="c1">#if num &lt;= 2:</span>
        <span class="k">if</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">random_shear_matrix</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)))</span>
            <span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">x</span> <span class="c1">#scale thickness by outer product of vectors</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1">#Monoclinic</span>
        <span class="c1">#elif num &lt;= 12:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">unique_axis</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
                <span class="n">alhpa</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unique_axis</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unique_axis</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">minangle</span><span class="p">,</span> <span class="n">maxangle</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ab</span><span class="o">/</span><span class="n">ratio</span><span class="p">)</span>

        <span class="c1">#Orthorhombic</span>
        <span class="c1">#lif num &lt;= 22:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;orthorhombic&quot;</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#ratio a/b</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">*</span><span class="n">ratio</span><span class="p">))</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span> <span class="n">ratio</span>

        <span class="c1">#Tetragonal</span>
        <span class="c1">#elif num &lt;= 41:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">thickness1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span><span class="o">/</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1">#Trigonal/Rhombohedral/Hexagonal</span>
        <span class="c1">#elif num &lt;= 75:</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
            <span class="k">if</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">abc</span><span class="p">[</span><span class="n">PA</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)(</span><span class="n">thickness1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">PA</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">volume</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">thickness1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">maxvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">minvec</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minvec</span> <span class="o">&lt;</span> <span class="n">maxvec</span><span class="p">:</span>
            <span class="n">smallvec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)),</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)))</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">minvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&gt;</span><span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">b</span><span class="o">&lt;</span><span class="n">maxvec</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">maxvec</span>
            <span class="ow">and</span> <span class="n">smallvec</span> <span class="o">&lt;</span> <span class="n">minvec</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&gt;</span><span class="n">minangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&gt;</span><span class="n">minangle</span>
            <span class="ow">and</span> <span class="n">alpha</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">&lt;</span><span class="n">maxangle</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">&lt;</span><span class="n">maxangle</span>
            <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">c</span><span class="o">&lt;</span><span class="n">max_ratio</span>
            <span class="ow">and</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">a</span><span class="o">&lt;</span><span class="n">max_ratio</span> <span class="ow">and</span> <span class="n">c</span><span class="o">/</span><span class="n">b</span><span class="o">&lt;</span><span class="n">max_ratio</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">para</span>

    <span class="c1">#If maxattempts tries have been made without success</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate lattice after &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; attempts&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="generate_lattice_0D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.generate_lattice_0D">[docs]</a><span class="k">def</span> <span class="nf">generate_lattice_0D</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">tol_m</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">maxattempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a lattice (3x3 matrix) according to the spacegroup symmetry and</span>
<span class="sd">    number of atoms. If the spacegroup has centering, we will transform to</span>
<span class="sd">    conventional cell setting. If the generated lattice does not meet the</span>
<span class="sd">    minimum angle and vector requirements, we try to generate a new one, up to</span>
<span class="sd">    maxattempts times.</span>
<span class="sd">    Note: The monoclinic Rod groups have different unique axes. Groups 3-7</span>
<span class="sd">        have unique axis a, while 8-12 have unique axis c. We use periodic</span>
<span class="sd">        axis c for all Rod groups.</span>

<span class="sd">    Args:</span>
<span class="sd">        num: number of the Rod group</span>
<span class="sd">        volume: volume of the lattice</span>
<span class="sd">        area: cross-sectional area of the unit cell in Angstroms squared. If</span>
<span class="sd">            set to None, a value is chosen automatically</span>
<span class="sd">        minvec: minimum allowed lattice vector length (among a, b, and c)</span>
<span class="sd">        max_ratio: largest allowed ratio of two lattice vector lengths</span>
<span class="sd">        maxattempts: the maximum number of attempts for generating a lattice</span>

<span class="sd">    Returns:</span>
<span class="sd">        a 3x3 matrix representing the lattice vectors of the unit cell. If</span>
<span class="sd">        generation fails, outputs a warning message and returns empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;spherical&quot;</span><span class="p">:</span>
        <span class="c1">#Use a cubic lattice with altered volume</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">((</span><span class="mi">3</span> <span class="o">*</span> <span class="n">volume</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">minvec</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate spherical lattice; volume too small compared to minvec&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;cylindrical&quot;</span><span class="p">:</span>
        <span class="c1">#Use a tetragonal lattice with altered volume</span>
        <span class="k">return</span> <span class="n">generate_lattice</span><span class="p">(</span><span class="s2">&quot;tetragonal&quot;</span><span class="p">,</span> <span class="n">volume</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="n">pi</span><span class="p">,</span> <span class="n">minvec</span><span class="o">=</span><span class="n">minvec</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="n">max_ratio</span><span class="p">,</span> <span class="n">maxattempts</span><span class="o">=</span><span class="n">maxattempts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="choose_wyckoff"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.choose_wyckoff">[docs]</a><span class="k">def</span> <span class="nf">choose_wyckoff</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose a Wyckoff position to fill based on the current number of atoms</span>
<span class="sd">    needed to be placed within a unit cell</span>
<span class="sd">    Rules:</span>
<span class="sd">        1) The new position&#39;s multiplicity is equal/less than (number).</span>
<span class="sd">        2) We prefer positions with large multiplicity.</span>

<span class="sd">    Args:</span>
<span class="sd">        group: a pyxtal.symmetry.Group object</span>
<span class="sd">        number: the number of atoms still needed in the unit cell</span>

<span class="sd">    Returns:</span>
<span class="sd">        a single index for the Wyckoff position. If no position is found,</span>
<span class="sd">        returns False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wyckoffs_organized</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">wyckoffs_organized</span>
    
    <span class="k">if</span> <span class="n">rand_u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">:</span> <span class="c1">#choose from high to low</span>
        <span class="k">for</span> <span class="n">wyckoff</span> <span class="ow">in</span> <span class="n">wyckoffs_organized</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">good_wyckoff</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wyckoff</span> <span class="ow">in</span> <span class="n">wyckoffs_organized</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wyckoff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wyckoff</span><span class="p">:</span>
                    <span class="n">good_wyckoff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_wyckoff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="n">good_wyckoff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="verify_distances"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.verify_distances">[docs]</a><span class="k">def</span> <span class="nf">verify_distances</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks the inter-atomic distance between all pairs of atoms in a crystal.</span>

<span class="sd">    Args:</span>
<span class="sd">        coordinates: a 1x3 list of fractional coordinates</span>
<span class="sd">        species: a list of atomic symbols for each coordinate</span>
<span class="sd">        lattice: a 3x3 matrix representing the lattice vectors of the unit cell</span>
<span class="sd">        factor: a tolerance factor for checking distances. A larger value means</span>
<span class="sd">            atoms must be farther apart</span>
<span class="sd">        PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">            Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        True if no atoms are too close together, False if any pair is too close</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
        <span class="n">specie1</span> <span class="o">=</span> <span class="n">species</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">specie2</span> <span class="o">=</span> <span class="n">species</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                <span class="n">d_min</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">)</span>
                <span class="n">tol</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">specie1</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="o">+</span> <span class="n">Element</span><span class="p">(</span><span class="n">specie2</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d_min</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Lattice"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice">[docs]</a><span class="k">class</span> <span class="nc">Lattice</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing and generating crystal lattices. Allows for specification</span>
<span class="sd">    of constraint values. Lattice types include triclinic, monoclinic, orthorhombic,</span>
<span class="sd">    tetragonal, trigonal, hexagonal, cubic, spherical, and cylindrical. The last</span>
<span class="sd">    two are used for generating point group structures, and do not actually represent</span>
<span class="sd">    a parallelepiped lattice.</span>

<span class="sd">    Args:</span>
<span class="sd">        ltype: a string representing the type of lattice (from the above list)</span>
<span class="sd">        volume: the volume, in Angstroms cubed, of the lattice</span>
<span class="sd">        kwargs: various values which may be defined. If none are defined, random ones</span>
<span class="sd">            will be generated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#Set required parameters</span>
        <span class="k">if</span> <span class="n">ltype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;triclinic&quot;</span><span class="p">,</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">,</span> <span class="s2">&quot;orthorhombic&quot;</span><span class="p">,</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;trigonal&quot;</span><span class="p">,</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="s2">&quot;spherical&quot;</span><span class="p">,</span> <span class="s2">&quot;cylindrical&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ltype</span> <span class="o">=</span> <span class="n">ltype</span>
        <span class="k">elif</span> <span class="n">ltype</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ltype</span> <span class="o">=</span> <span class="s2">&quot;triclinic&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Invalid lattice type.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="n">PBC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">PBC</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#Set optional values</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="s2">&quot;thickness&quot;</span><span class="p">,</span> <span class="s2">&quot;unique_axis&quot;</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_matrix</span><span class="p">()</span>
        
<div class="viewcode-block" id="Lattice.generate_para"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.generate_para">[docs]</a>    <span class="k">def</span> <span class="nf">generate_para</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">generate_lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">generate_lattice_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">generate_lattice_1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">generate_lattice_0D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ltype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.generate_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.generate_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">generate_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a 3x3 matrix for the lattice based on the lattice type and volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Try multiple times in case of failure</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">para</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_para</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">para</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">para2matrix</span><span class="p">(</span><span class="n">para</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not generate lattice matrix.&quot;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Lattice.get_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 3x3 numpy array representing the lattice vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Lattice matrix undefined.&quot;</span><span class="p">)</span>
            <span class="k">return</span></div>

<div class="viewcode-block" id="Lattice.get_para"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.get_para">[docs]</a>    <span class="k">def</span> <span class="nf">get_para</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of lattice parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.set_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.set_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: matrix must be a 3x3 numpy array or list&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">matrix</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_matrix</span><span class="p">()</span>
        <span class="n">para</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">para</span></div>

<div class="viewcode-block" id="Lattice.set_para"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.set_para">[docs]</a>    <span class="k">def</span> <span class="nf">set_para</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">para</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">para</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">radians</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">para</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">rad</span>
                <span class="n">para</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*=</span> <span class="n">rad</span>
                <span class="n">para</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*=</span> <span class="n">rad</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">para2matrix</span><span class="p">(</span><span class="n">para</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="Lattice.reset_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.reset_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">reset_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_matrix</span><span class="p">()</span>
            <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span></div>

<div class="viewcode-block" id="Lattice.generate_point"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.generate_point">[docs]</a>    <span class="k">def</span> <span class="nf">generate_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;spherical&quot;</span><span class="p">:</span>
            <span class="c1">#Choose a point within an octant of the unit sphere</span>
            <span class="k">while</span> <span class="n">dsquared</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1">#Randomly flip some coordinates</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
                <span class="c1">#Scale the point by the max radius</span>
                <span class="k">if</span> <span class="n">rand_u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">point</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;cylindrical&quot;</span><span class="p">:</span>
            <span class="c1">#Choose a point within an octant of the unit sphere</span>
            <span class="k">while</span> <span class="n">dsquared</span><span class="p">([</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1">#Randomly flip some coordinates</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#Scale the point by the max radius</span>
                <span class="k">if</span> <span class="n">rand_u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">point</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ltype</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
                        <span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">point</span></div>

<div class="viewcode-block" id="Lattice.from_para"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.from_para">[docs]</a>    <span class="k">def</span> <span class="nf">from_para</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="s2">&quot;triclinic&quot;</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Lattice object from 6 lattice parameters. Additional keyword arguments</span>
<span class="sd">        are available. Unless specified by the keyword random=True, does not create a</span>
<span class="sd">        new matrix upon calling reset_matrix. This allows for generation of random</span>
<span class="sd">        crystals with a specific choice of unit cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            a, b, c: The length (in Angstroms) of the unit cell vectors</span>
<span class="sd">            alpha: the angle (in degrees) between the b and c vectors</span>
<span class="sd">            beta: the angle (in degrees) between the a and c vectors</span>
<span class="sd">            gamma: the angle (in degrees) between the a and b vectors</span>
<span class="sd">            ltype: the lattice type (&quot;cubic, tetragonal, etc.&quot;). Also available are &quot;spherical&quot;,</span>
<span class="sd">                which confines generated points to lie within a sphere, and &quot;cylindrical&quot;, which</span>
<span class="sd">                confines generated points to lie within a cylinder (oriented about the z axis)</span>
<span class="sd">            radians: whether or not to use radians (instead of degrees) for the lattice angles</span>
<span class="sd">            PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">                Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">            area: The cross-sectional area (in Angstroms squared). Only used to generate 1D</span>
<span class="sd">                crystals</span>
<span class="sd">            thickness: The unit cell&#39;s non-periodic thickness (in Angstroms). Only used to</span>
<span class="sd">                generate 2D crystals</span>
<span class="sd">            unique_axis: The unique axis for certain symmetry (and especially layer) groups.</span>
<span class="sd">                Because the symmetry operations are not also transformed, you should use the</span>
<span class="sd">                default values for random crystal generation</span>
<span class="sd">            random: If False, keeps the stored values for the lattice geometry even upon applying</span>
<span class="sd">                reset_matrix. To alter the matrix, use set_matrix() or set_para</span>

<span class="sd">        Returns:</span>
<span class="sd">            a Lattice object with the specified parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cell_matrix</span> <span class="o">=</span> <span class="n">para2matrix</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span><span class="p">),</span> <span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: invalid cell parameters for lattice.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">)</span>
        <span class="c1">#Initialize a Lattice instance</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">l</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">l</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">l</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">rad</span>
        <span class="n">l</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">rad</span>
        <span class="n">l</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">rad</span>
        <span class="n">l</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">cell_matrix</span>
        <span class="n">l</span><span class="o">.</span><span class="n">ltype</span> <span class="o">=</span> <span class="n">ltype</span>
        <span class="n">l</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>
        <span class="n">l</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="Lattice.from_matrix"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.Lattice.from_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="s2">&quot;triclinic&quot;</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Lattice object from a 3x3 cell matrix. Additional keyword arguments</span>
<span class="sd">        are available. Unless specified by the keyword random=True, does not create a</span>
<span class="sd">        new matrix upon calling reset_matrix. This allows for generation of random</span>
<span class="sd">        crystals with a specific choice of unit cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            matrix: a 3x3 real matrix (numpy array or nested list) describing the cell vectors</span>
<span class="sd">            ltype: the lattice type (&quot;cubic, tetragonal, etc.&quot;). Also available are &quot;spherical&quot;,</span>
<span class="sd">                which confines generated points to lie within a sphere, and &quot;cylindrical&quot;, which</span>
<span class="sd">                confines generated points to lie within a cylinder (oriented about the z axis)</span>
<span class="sd">            PBC: A periodic boundary condition list, where 1 means periodic, 0 means not periodic.</span>
<span class="sd">                Ex: [1,1,1] -&gt; full 3d periodicity, [0,0,1] -&gt; periodicity along the z axis</span>
<span class="sd">            area: The cross-sectional area (in Angstroms squared). Only used to generate 1D</span>
<span class="sd">                crystals</span>
<span class="sd">            thickness: The unit cell&#39;s non-periodic thickness (in Angstroms). Only used to</span>
<span class="sd">                generate 2D crystals</span>
<span class="sd">            unique_axis: The unique axis for certain symmetry (and especially layer) groups.</span>
<span class="sd">                Because the symmetry operations are not also transformed, you should use the</span>
<span class="sd">                default values for random crystal generation</span>
<span class="sd">            random: If False, keeps the stored values for the lattice geometry even upon applying</span>
<span class="sd">                reset_matrix. To alter the matrix, use set_matrix() or set_para</span>

<span class="sd">        Returns:</span>
<span class="sd">            a Lattice object with the specified parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Lattice matrix must be 3x3&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="c1">#Initialize a Lattice instance</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="n">PBC</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">l</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">l</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">l</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">l</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="n">l</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="n">l</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">l</span><span class="o">.</span><span class="n">ltype</span> <span class="o">=</span> <span class="n">ltype</span>
        <span class="n">l</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>
        <span class="n">l</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">l</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ltype</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; lattice:&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">a: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">b: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">c: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">alpha: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="n">deg</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">beta: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="n">deg</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">gamma: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">*</span><span class="n">deg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="random_crystal"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal">[docs]</a><span class="k">class</span> <span class="nc">random_crystal</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing and generating atomic crystals based on symmetry</span>
<span class="sd">    constraints. Given a spacegroup, list of atomic symbols, the stoichiometry,</span>
<span class="sd">    and a volume factor, generates a random crystal consistent with the</span>
<span class="sd">    spacegroup&#39;s symmetry. This crystal is stored as a pymatgen struct via</span>
<span class="sd">    self.struct</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sg: the international spacegroup number</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        tm: the Tol_matrix object used to generate</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="random_crystal.init_common"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.init_common">[docs]</a>    <span class="k">def</span> <span class="nf">init_common</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Common init functionality for 0-3D cases of random_crystal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="n">Group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span>
            <span class="sd">&quot;&quot;&quot;A pyxtal.symmetry.Group object storing information about the space/layer</span>
<span class="sd">            /Rod/point group, and its Wyckoff positions.&quot;&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">number</span>
        <span class="sd">&quot;&quot;&quot;The international group number of the crystal:</span>
<span class="sd">        1-230 for 3D space groups</span>
<span class="sd">        1-80 for 2D layer groups</span>
<span class="sd">        1-75 for 1D Rod groups</span>
<span class="sd">        1-32 for crystallographic point groups</span>
<span class="sd">        None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numattempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The number of attempts needed to generate the crystal. Has a maximum</span>
<span class="sd">        value of max1*max2*max3.&quot;&quot;&quot;</span>
        <span class="n">numIons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numIons</span><span class="p">)</span> <span class="c1">#must convert it to np.array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="sd">&quot;&quot;&quot;The supplied volume factor for the unit cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons0</span> <span class="o">=</span> <span class="n">numIons</span>
        <span class="sd">&quot;&quot;&quot;The number of each type of atom in the PRIMITIVE cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numIons0</span> <span class="o">*</span> <span class="n">cellsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The number of each type of atom in the CONVENTIONAL cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
        <span class="sd">&quot;&quot;&quot;A list of atomic symbols for the types of atoms in the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msgs</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A list of warning messages to use during generation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#Use the provided lattice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">lattice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">volume</span>
        <span class="k">elif</span> <span class="n">lattice</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#Determine the unique axis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
                    <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
                    <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_axis</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
            <span class="c1">#Generate a Lattice instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">estimate_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;The volume of the generated unit cell.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">lattice_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">,</span> <span class="n">unique_axis</span><span class="o">=</span><span class="n">unique_axis</span><span class="p">)</span>
        <span class="c1">#Set the tolerance matrix</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tol_matrix</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tol_matrix</span> <span class="o">=</span> <span class="n">tm</span>
            <span class="sd">&quot;&quot;&quot;The Tol_matrix object used for checking inter-atomic distances within the structure.&quot;&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tol_matrix</span> <span class="o">=</span> <span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="n">tm</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: tm must either be a Tol_matrix object or a prototype string for initializing one.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span>
        <span class="c1">#Generate the crystal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_crystal</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="sd">&quot;&quot;&quot;The number of periodic dimensions of the crystal&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Group</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">number</span>
        <span class="sd">&quot;&quot;&quot;The international spacegroup number of the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;The periodic boundary axes of the crystal&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_common</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span>

<div class="viewcode-block" id="random_crystal.Msgs"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.Msgs">[docs]</a>    <span class="k">def</span> <span class="nf">Msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a set of error and warning message if generation fails.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span> <span class="o">=</span> <span class="s1">&#39;Error: the number is incompatible with the wyckoff sites choice&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span> <span class="o">=</span> <span class="s1">&#39;Error: failed in the cycle of generating structures&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg3</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of adding species&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg4</span> <span class="o">=</span> <span class="s1">&#39;Warning: failed in the cycle of choosing wyckoff sites&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg5</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the specie&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msg6</span> <span class="o">=</span> <span class="s1">&#39;Finishing: added the whole structure&#39;</span></div>

<div class="viewcode-block" id="random_crystal.check_compatible"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.check_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">check_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the number of atoms is compatible with the Wyckoff</span>
<span class="sd">        positions. Considers the number of degrees of freedom for each Wyckoff</span>
<span class="sd">        position, and makes sure at least one valid combination of WP&#39;s exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N_site</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">wyckoffs_organized</span><span class="p">]</span>
        <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#remove WP&#39;s with no freedom once they are filled</span>
        <span class="n">removed_wyckoffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">numIon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">:</span>
            <span class="c1">#Check that the number of ions is a multiple of the smallest Wyckoff position</span>
            <span class="k">if</span> <span class="n">numIon</span> <span class="o">%</span> <span class="n">N_site</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Check if smallest WP has at least one degree of freedom</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">wyckoffs_organized</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Subtract from the number of ions beginning with the smallest Wyckoff positions</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">numIon</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">wyckoffs_organized</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                            <span class="n">removed</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">while</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">wp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_wyckoffs</span><span class="p">:</span>
                                <span class="c1">#Check if WP has at least one degree of freedom</span>
                                <span class="n">op</span> <span class="o">=</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">remaining</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])):</span>
                                    <span class="n">removed_wyckoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                                    <span class="n">removed</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">has_freedom</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">has_freedom</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Wyckoff Positions have no degrees of freedom</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="random_crystal.to_file"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;cif&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a file with the given filename and file type to store the structure.</span>
<span class="sd">        By default, creates cif files for crystals and xyz files for clusters.</span>
<span class="sd">        By default, the filename is based on the stoichiometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            fmt: the file type (&#39;cif&#39;, &#39;xyz&#39;, etc.)</span>
<span class="sd">            filename: the file path</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nothing. Creates a file at the specified path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">given</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">given</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">formula</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">fmt</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">formula</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">fmt</span>
            <span class="c1">#Check if filename already exists</span>
            <span class="c1">#If it does, add a new number to end of filename</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">given</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[:(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">outdir</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">given</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">outdir</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">fmt</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">outdir</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
                        <span class="k">return</span> <span class="s2">&quot;Could not create file: too many files already created.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outdir</span> <span class="o">=</span> <span class="n">filename</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">outdir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">outdir</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;Output file to &quot;</span> <span class="o">+</span> <span class="n">outdir</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot create file: structure did not generate.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="random_crystal.generate_crystal"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal.generate_crystal">[docs]</a>    <span class="k">def</span> <span class="nf">generate_crystal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max1</span><span class="o">=</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="o">=</span><span class="n">max2</span><span class="p">,</span> <span class="n">max3</span><span class="o">=</span><span class="n">max3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The main code to generate a random atomic crystal. If successful,</span>
<span class="sd">        stores a pymatgen.core.structure object in self.struct and sets</span>
<span class="sd">        self.valid to True. If unsuccessful, sets self.valid to False and</span>
<span class="sd">        outputs an error message.</span>

<span class="sd">        Args:</span>
<span class="sd">            max1: the number of attempts for generating a lattice</span>
<span class="sd">            max2: the number of attempts for a given lattice</span>
<span class="sd">            max3: the number of attempts for a given Wyckoff position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Check the minimum number of degrees of freedom within the Wyckoff positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numattempts</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_compatible</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Msg1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">degrees</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max1</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max2</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">max3</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="c1">#Calculate a minimum vector length for generating a lattice</span>
            <span class="n">minvector</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">),</span> <span class="n">tol_m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cycle1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max1</span><span class="p">):</span>
                <span class="c1">#1, Generate a lattice</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reset_matrix</span><span class="p">()</span>           
                <span class="n">cell_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1">#Check that the correct volume was generated</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">random</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span> 
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error, volume is not equal to the estimated value: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="s1">&#39; -&gt; &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell_para:  &#39;</span><span class="p">,</span> <span class="n">matrix2para</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">))</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#to store the added coordinates</span>
                <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1">#to store the corresponding specie</span>
                <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">for</span> <span class="n">cycle2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max2</span><span class="p">):</span>
                    <span class="n">coordinates_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">)</span>
                    <span class="n">sites_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_total</span><span class="p">)</span>
                    
        	        <span class="c1">#Add specie by specie</span>
                    <span class="k">for</span> <span class="n">numIon</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numIons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
                        <span class="n">numIon_added</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">tol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">Element</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">covalent_radius</span><span class="p">,</span> <span class="n">tol_m</span><span class="p">)</span>

                        <span class="c1">#Now we start to add the specie to the wyckoff position</span>
                        <span class="n">cycle3</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">while</span> <span class="n">cycle3</span> <span class="o">&lt;</span> <span class="n">max3</span><span class="p">:</span>
                            <span class="c1">#Choose a random Wyckoff position for given multiplicity: 2a, 2b, 2c</span>
                            <span class="n">ops</span> <span class="o">=</span> <span class="n">choose_wyckoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">numIon</span><span class="o">-</span><span class="n">numIon_added</span><span class="p">)</span> 
                            <span class="k">if</span> <span class="n">ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        	        	    <span class="c1">#Generate a list of coords from ops</span>
                                <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">generate_point</span><span class="p">()</span>
                                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
                                <span class="c1">#Merge coordinates if the atoms are close</span>
                                <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">good_merge</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">merge_coordinate</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">good_merge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                                    <span class="n">coords_toadd</span> <span class="o">=</span> <span class="n">filtered_coords</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">check_distance</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">,</span> <span class="n">coords_toadd</span><span class="p">,</span> <span class="n">sites_tmp</span><span class="p">,</span> <span class="p">[</span><span class="n">specie</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">),</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol_matrix</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">):</span>
                                        <span class="k">if</span> <span class="n">coordinates_tmp</span> <span class="o">==</span> <span class="p">[]:</span>
                                            <span class="n">coordinates_tmp</span> <span class="o">=</span> <span class="n">coords_toadd</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">coordinates_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">coordinates_tmp</span><span class="p">,</span> <span class="n">coords_toadd</span><span class="p">])</span>
                                        <span class="n">sites_tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                        <span class="n">numIon_added</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_toadd</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">cycle3</span> <span class="o">+=</span> <span class="mi">1</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">numattempts</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                                        <span class="n">coordinates_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">coordinates_tmp</span><span class="p">)</span>
                                        <span class="n">sites_total</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sites_tmp</span><span class="p">)</span>
                                        <span class="k">break</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">cycle3</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">numattempts</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">cycle3</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">numattempts</span> <span class="o">++</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">!=</span> <span class="n">numIon</span><span class="p">:</span>
                            <span class="k">break</span>  <span class="c1">#need to repeat from the 1st species</span>

                    <span class="k">if</span> <span class="n">numIon_added</span> <span class="o">==</span> <span class="n">numIon</span><span class="p">:</span>
                        <span class="n">good_structure</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#reset the coordinates and sites</span>
                        <span class="n">coordinates_total</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">sites_total</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="n">good_structure</span><span class="p">:</span>
                    <span class="n">final_coor</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">final_site</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">final_number</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">final_lattice</span> <span class="o">=</span> <span class="n">cell_matrix</span>
                    <span class="k">for</span> <span class="n">coor</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinates_total</span><span class="p">,</span> <span class="n">sites_total</span><span class="p">):</span>
                        <span class="n">final_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
                        <span class="n">final_site</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                        <span class="n">final_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">final_coor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_coor</span> <span class="o">=</span> <span class="n">Add_vacuum</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_coor</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_matrix</span> <span class="o">=</span> <span class="n">final_lattice</span>   
                        <span class="sd">&quot;&quot;&quot;A 3x3 matrix representing the lattice of the unit</span>
<span class="sd">                        cell.&quot;&quot;&quot;</span>                 
                        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">)</span>
                        <span class="sd">&quot;&quot;&quot;The fractional coordinates for each atom in the</span>
<span class="sd">                        final structure&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">final_site</span>
                        <span class="sd">&quot;&quot;&quot;A list of atomic symbols corresponding to the type</span>
<span class="sd">                        of atom for each site in self.coordinates&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">final_site</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">))</span>
                        <span class="sd">&quot;&quot;&quot;A pymatgen.core.structure.Structure object for the</span>
<span class="sd">                        final generated crystal.&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spg_struct</span> <span class="o">=</span> <span class="p">(</span><span class="n">final_lattice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_coor</span><span class="p">),</span> <span class="n">final_number</span><span class="p">)</span>
                        <span class="sd">&quot;&quot;&quot;A list of information describing the generated</span>
<span class="sd">                        crystal, which may be used by spglib for symmetry</span>
<span class="sd">                        analysis.&quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">return</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verify_distances</span><span class="p">(</span><span class="n">final_coor</span><span class="p">,</span> <span class="n">final_site</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">,</span> <span class="n">PBC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PBC</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lattice_matrix</span> <span class="o">=</span> <span class="n">final_lattice</span>   
                            <span class="sd">&quot;&quot;&quot;A 3x3 matrix representing the lattice of the unit</span>
<span class="sd">                            cell.&quot;&quot;&quot;</span>        
                            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">final_coor</span>
                            <span class="sd">&quot;&quot;&quot;The absolute coordinates for each atom in the</span>
<span class="sd">                            final structure&quot;&quot;&quot;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">final_site</span>
                            <span class="sd">&quot;&quot;&quot;A list of atomic symbols corresponding to the type</span>
<span class="sd">                            of atom for each site in self.coordinates&quot;&quot;&quot;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">final_site</span>
                            <span class="sd">&quot;&quot;&quot;A list of atomic symbols corresponding to the type</span>
<span class="sd">                            of atom for each site in self.coordinates&quot;&quot;&quot;</span>
                            <span class="n">absolute_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">cell_matrix</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="n">absolute_coords</span><span class="p">)</span>
                            <span class="sd">&quot;&quot;&quot;A pymatgen.core.structure.Molecule object for the</span>
<span class="sd">                            final generated cluster.&quot;&quot;&quot;</span>
                            <span class="c1">#Calculate binding box</span>
                            <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                            <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">get_boxed_structure</span><span class="p">(</span><span class="n">maxx</span><span class="o">-</span><span class="n">minx</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">maxy</span><span class="o">-</span><span class="n">miny</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">maxz</span><span class="o">-</span><span class="n">minz</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>
                            <span class="sd">&quot;&quot;&quot;A pymatgen.core.structure.Structure object for the</span>
<span class="sd">                            final generated object.&quot;&quot;&quot;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="sd">&quot;&quot;&quot;Whether or not a valid crystal was generated.&quot;&quot;&quot;</span>
                            <span class="k">return</span>
        <span class="k">if</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wyckoff positions have no degrees of freedom.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msg2</span></div></div>

<div class="viewcode-block" id="random_crystal_2D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_2D">[docs]</a><span class="k">class</span> <span class="nc">random_crystal_2D</span><span class="p">(</span><span class="n">random_crystal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A 2d counterpart to random_crystal. Generates a random atomic crystal based</span>
<span class="sd">    on a 2d layer group instead of a 3d spacegroup. Note that each layer group</span>
<span class="sd">    is equal to a corresponding 3d spacegroup, but without periodicity in one</span>
<span class="sd">    direction. The generated pymatgen structure can be accessed via self.struct</span>

<span class="sd">    Args:</span>
<span class="sd">        group: the layer group number between 1 and 80. NOT equal to the</span>
<span class="sd">            international space group number, which is between 1 and 230</span>
<span class="sd">            OR, a pyxtal.symmetry.Group object</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        thickness: the thickness, in Angstroms, of the unit cell in the 3rd</span>
<span class="sd">            dimension (the direction which is not repeated periodically)</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="sd">&quot;&quot;&quot;The number of periodic dimensions of the crystal&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;The periodic boundary axes of the crystal&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Group</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">number</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">number</span>
        <span class="sd">&quot;&quot;&quot;The layer group number of the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span> <span class="o">=</span> <span class="n">Layergroup</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A Layergroup object for the crystal&#39;s layer group.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lgp</span><span class="o">.</span><span class="n">sgnumber</span>
        <span class="sd">&quot;&quot;&quot;The number (between 1 and 230) for the international spacegroup.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span> <span class="o">=</span> <span class="n">thickness</span>
        <span class="sd">&quot;&quot;&quot;the thickness, in Angstroms, of the unit cell in the 3rd</span>
<span class="sd">        dimension.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_common</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span></div>

<div class="viewcode-block" id="random_crystal_1D"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_crystal_1D">[docs]</a><span class="k">class</span> <span class="nc">random_crystal_1D</span><span class="p">(</span><span class="n">random_crystal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A 1d counterpart to random_crystal. Generates a random atomic crystal based</span>
<span class="sd">    on a 1d Rod group instead of a 3d spacegroup. The generated pymatgen</span>
<span class="sd">    structure can be accessed via self.struct</span>

<span class="sd">    Args:</span>
<span class="sd">        group: the Rod group number between 1 and 75. NOT equal to the</span>
<span class="sd">            international space group number, which is between 1 and 230</span>
<span class="sd">            OR, a pyxtal.symmetry.Group object</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        area: the effective cross-sectional area, in Angstroms squared, of the</span>
<span class="sd">            unit cell</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;The number of periodic dimensions of the crystal&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;The periodic axis of the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The international space group number (there is not a 1-1 correspondence</span>
<span class="sd">        with Rod groups).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="n">area</span>
        <span class="sd">&quot;&quot;&quot;the effective cross-sectional area, in Angstroms squared, of the</span>
<span class="sd">        unit cell.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_common</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span></div>

<div class="viewcode-block" id="random_cluster"><a class="viewcode-back" href="../../pyxtal.crystal.html#pyxtal.crystal.random_cluster">[docs]</a><span class="k">class</span> <span class="nc">random_cluster</span><span class="p">(</span><span class="n">random_crystal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A 0d counterpart to random_crystal. Generates a random atomic cluster based</span>
<span class="sd">    on a 0d Point group instead of a 3d spacegroup. The generated pymatgen</span>
<span class="sd">    structure can be accessed via self.struct</span>

<span class="sd">    Args:</span>
<span class="sd">        group: the Schoenflies symbol for the point group (ex: &quot;Oh&quot;, &quot;C5v&quot;, &quot;D3&quot;)</span>
<span class="sd">            OR the number between 1-32 for a crystallographic point group,</span>
<span class="sd">            OR, a pyxtal.symmetry.Group object</span>
<span class="sd">            See:</span>
<span class="sd">            https://en.wikipedia.org/wiki/Schoenflies_notation#Point_groups</span>
<span class="sd">            for more information</span>
<span class="sd">        species: a list of atomic symbols for each ion type</span>
<span class="sd">        numIons: a list of the number of each type of atom within the</span>
<span class="sd">            primitive cell (NOT the conventional cell)</span>
<span class="sd">        factor: a volume factor used to generate a larger or smaller</span>
<span class="sd">            unit cell. Increasing this gives extra space between atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="n">Tol_matrix</span><span class="p">(</span><span class="n">prototype</span><span class="o">=</span><span class="s2">&quot;atomic&quot;</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The number of periodic dimensions of the crystal&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PBC</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;The periodic axis of the crystal.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The international space group number (there is not a 1-1 correspondence</span>
<span class="sd">        with Point groups).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_common</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">numIons</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1">#-------------------------------- Options -------------------------</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--spacegroup&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;sg&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired space group number (1-230) or layer group number (1-80), e.g., 36&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-e&quot;</span><span class="p">,</span> <span class="s2">&quot;--element&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;element&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;Li&#39;</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired elements: e.g., Li&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;element&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-n&quot;</span><span class="p">,</span> <span class="s2">&quot;--numIons&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;numIons&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired numbers of atoms: 16&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;numIons&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-f&quot;</span><span class="p">,</span> <span class="s2">&quot;--factor&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;factor&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;volume factor: default 1.0&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;factor&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="s2">&quot;--verbosity&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;verbosity&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;verbosity: default 0; higher values print more information&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;verbosity&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-a&quot;</span><span class="p">,</span> <span class="s2">&quot;--attempts&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;attempts&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;number of crystals to generate: default 1&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;attempts&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--outdir&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;outdir&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> 
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Directory for storing output cif files: default &#39;out&#39;&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;outdir&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-d&quot;</span><span class="p">,</span> <span class="s2">&quot;--dimension&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;dimension&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;dimension&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;desired dimension: (3, 2, or 1 for 3d, 2d, or 1D respectively): default 3&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s2">&quot;-t&quot;</span><span class="p">,</span> <span class="s2">&quot;--thickness&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;thickness&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Thickness, in Angstroms, of a 2D crystal, or area of a 1D crystal, None generates a value automatically: default None&quot;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">sg</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">dimension</span>
    <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sg</span> <span class="o">&gt;</span> <span class="mi">230</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid space group number. Must be between 1 and 230.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sg</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid layer group number. Must be between 1 and 80.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sg</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid Rod group number. Must be between 1 and 75.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid dimension. Use dimension 0, 1, 2, or 3.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">element</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">element</span>
    <span class="n">number</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">numIons</span>
    <span class="n">numIons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">number</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="n">numIons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>
        <span class="n">numIons</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">)]</span>

    <span class="n">factor</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">factor</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Volume factor must be greater than 0.&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">verbosity</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">verbosity</span>
    <span class="n">attempts</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">attempts</span>
    <span class="n">outdir</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">outdir</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">dimension</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">thickness</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>

    <span class="n">filecount</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#To check whether a file already exists</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">attempts</span><span class="p">):</span>
        <span class="n">numIons0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numIons</span><span class="p">)</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">sg</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">rand_crystal</span> <span class="o">=</span> <span class="n">random_crystal</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">numIons0</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="n">sg1</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rand_crystal</span> <span class="o">=</span> <span class="n">random_crystal_2D</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">numIons0</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="n">sg1</span> <span class="o">=</span> <span class="n">rand_crystal</span><span class="o">.</span><span class="n">sg</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rand_crystal</span> <span class="o">=</span> <span class="n">random_crystal_1D</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">numIons0</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="n">sg1</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rand_crystal</span> <span class="o">=</span> <span class="n">random_cluster</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">numIons0</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="n">sg1</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">timespent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rand_crystal</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="c1">#Output a cif file</span>
            <span class="n">written</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">struct</span><span class="o">.</span><span class="n">composition</span><span class="p">)</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">cifpath</span> <span class="o">=</span> <span class="n">outdir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">filecount</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.cif&#39;</span>
                <span class="k">while</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cifpath</span><span class="p">):</span>
                    <span class="n">filecount</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cifpath</span> <span class="o">=</span> <span class="n">outdir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">filecount</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.cif&#39;</span>
                <span class="n">CifWriter</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">struct</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">cifpath</span><span class="p">)</span>
                <span class="n">written</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
            <span class="c1">#POSCAR output</span>
            <span class="c1">#rand_crystal.struct.to(fmt=&quot;poscar&quot;, filename = &#39;1.vasp&#39;)</span>

            <span class="c1">#spglib style structure called cell</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">spg_struct</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)[</span><span class="s1">&#39;number&#39;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Space group  requested:&#39;</span><span class="p">,</span> <span class="n">sg1</span><span class="p">,</span> <span class="s1">&#39; generated:&#39;</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">written</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Output to &quot;</span><span class="o">+</span><span class="n">cifpath</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Could not write cif file.&quot;</span><span class="p">)</span>

            <span class="c1">#Print additional information about the structure</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time required for generation: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timespent</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">rand_crystal</span><span class="o">.</span><span class="n">struct</span><span class="p">)</span>


        <span class="c1">#If generation fails</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;something is wrong&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Time spent during generation attempt: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timespent</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyXtal 0.1dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Qiang Zhu, Scott Fredericks.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>